{"componentChunkName":"component---src-pages-search-js","path":"/search/","webpackCompilationHash":"6149c6488b3741629f22","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"# Why Kotlin?\r\n\r\nKotlin을 처음 공부하고 사용하면서는 많은 불편함을 느꼈습니다  \r\n하지만 계속 쓰면 쓸수록 Kotlin이 Java보다 편하다는 명확한 이점을 파악하였고 왜 Kotlin을 사용하는 지에 대해 포스팅하게 되었습니다\r\n\r\n\r\n## 1. 간결한 코드  \r\n제가 생각하는 첫번째 장점은 간결한 코드가 가능하다는 것입니다  \r\n어느 lang이나 간결한 코드는 가능하겠지만, 뒤 따라오는 문제는 간결성 - 가독성은 서로 친하지 않다는 것입니다  \r\n하지만 koltin을 사용해보면 JetBrrains사에서 언어를 만들때 간결설과 가독성을 얼마나 고심하며 설계 했는지가 명확히 들어 납니다  \r\n간단한 샘플을 보면 명확히 이해되실 겁니다\r\n\r\n\r\n**Java Code <span class='sub_header'>(Variables Null Check)</span>**\r\n```java\r\n\r\nPerson person = new Person(\"deokhwa\", \"kim\");\r\n\r\npublic String getFirstName(){     \r\n  \r\n    if(person != null && person.getFirstName() != null){ //Null Check  /* highlight-line */  \r\n            return person.getFirstName();\r\n    }\r\n        \r\n    return \"\";\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n<br/>\r\n\r\n**Kotlin Code <span class='sub_header'>(Variables Null Check)</span>**\r\n```kotlin\r\n\r\nvar person = Person(\"deokhwa\", \"kim\");\r\n\r\nfun getFirstName() : String{\r\n    return person?.firstName ?: \"\" //Null Check   /* highlight-line */  \r\n}\r\n\r\n```\r\n다음과 같이 간단하게 `?`만로 `Null Check`가 가능해서 보시는 것과 같이 단 한줄로 기능이 구현됩니다  \r\n그리고 `간결성`과 더불어서 java코드는 줄을 쭉 따라 내려가며 이해해야 하지만 kotlin코드는 한줄을 보고 단번에 이해할 수 있어서 `가독성`도 더 좋습니다\r\n\r\n\r\n---\r\n***다음은 이름의 성을 대문자로 반환하는 함수를 만들어 보겠습니다***\r\n\r\n\r\n**Java Code <span class='sub_header'>(Function)</span>**  \r\n```java\r\n\r\nPerson person = new Person(\"deokhwa\", \"kim\");\r\n\r\npublic String getLastNameUpper(){       \r\n    return person.getLastName().toUpperCase();  /* highlight-line */   \r\n}\r\n\r\n```\r\n\r\n<br/>\r\n<br/>\r\n\r\n**Kotlin Code <span class='sub_header'>(Function)</span>**  \r\n```kotlin\r\nPerson person = new Person(\"deokhwa\", \"kim\");\r\n\r\nfun getLastNameUpper() = person.name.toUpperCase() /* highlight-line */    \r\n\r\n```\r\n\r\n**보이시나요?**  \r\njava코드도 간단히 구현 가능하지만 kotlin으로 구현했을 때의 더 간결함!  \r\n여기서 `Null Check`를 한번 추가해 보겠습니다  \r\n\r\n---\r\n***성을 대문자로 반환하지만 Null 값이면 빈 String값을 반환하는 코드***\r\n\r\n**Java Code <span class='sub_header'>(Function & Null Check)</span>**  \r\n```java\r\n\r\nPerson person = new Person(\"deokhwa\", \"kim\");\r\n\r\npublic String getLastNameUpper(){       \r\n    /* highlight-range{1-2} */   \r\n    if(person != null && person.getLastName != null){   //Null Check\r\n         return person.getLastName().toUpperCase();     //Upper\r\n    }\r\n    return \"\";  \r\n}\r\n\r\n```\r\n\r\n<br/>\r\n<br/>\r\n\r\n**Kotlin Code <span class='sub_header'>(Function & Null Check)</span>**  \r\n```kotlin\r\nPerson person = new Person(\"deokhwa\", \"kim\");\r\n\r\nfun getLastNameUpper() = person?.name?.toUpperCase() ?: \"\" //Null Check & Upper /* highlight-line */    \r\n\r\n```  \r\n이 처럼 간결함이 합쳐져서 더욱 간결해진 kotlin 코드를 만나 볼 수 있었습니다  \r\n\r\n<br/>\r\n\r\n---\r\n\r\n## 2. 안전성과 호환성\r\n\r\n> **1. 안전성**  \r\n>> 시스템에서 가장 중요한것은 안전성입니다  \r\n>> 이런 측면에서 java는 전세계인들의 사랑을 받아왔고 수년간의 노하우로 안전성에서 인정받아 지금도 가장 널리 사용되는 언어 중 하나입니다    \r\n>> kotlin은 이런 안전성을 확보하기 위해 기존 jvm 위에서 java와 같이 실행되도록 구현되었습니다   \r\n\r\n![java_and_kotlin on jvm](/resources/images/2019/java_and_kotlin_jvm.png)\r\n<span class=\"img_caption\">source [Introduction to Kotlin](https://subscription.packtpub.com/book/application_development/9781789349252/2/ch02lvl1sec17/introduction-to-kotlin) </span>\r\n\r\n>> 보시는 것 같이 java던 kotlin이던 각각의 컴파일러를 거쳐 class로 생성되어 jvm에서 똑같이 동작되어 `안전성`을 그대로 가져왔습니다\r\n\r\n<br/>\r\n\r\n> **2. 호환성**  \r\n>> kotlin은 java를 100% 호환되도록 설계되었습니다  \r\n>> 그래서 사용자는 java와 kotlin을 구분없이 사용가능하고 Intellij에서는 java코드를 kotlin코드롤 자동변환해 주는 기능도 제공합니다\r\n\r\n![java_to_kotlin_convert](/resources/images/2019/java_to_kotlin_convert.png)\r\n\r\n>> 이는 사용자와 시스템 모두에게 매우 긍정적인 측면으로 작용합니다  \r\n>> 호환과 관련된 보다 자세한 사항은 [Jay Tilu Blog](https://medium.com/jay-tillu/how-kotlin-provides-100-interoperability-with-java-5ee132869038)를 참조하시면 좋을꺼 같습니다  \r\n\r\n***java의 서드파티(lombok, kryo등등)까지 완벽히 지원되지는 않습니다***\r\n\r\n\r\n---\r\n\r\n## 3. 커뮤니티의 활성화  \r\n>> 예전에 XNA 프레임워크에 대해 공부한적이 있었습니다  \r\n>> 남들이 많이 사용하지 않았지만, 나름대로 pc/xbox/windowMoblie을 하나로 모아 게임을 개발할 수 있다는 것에 흥미를 느끼고 공부했었습니다  \r\n>> 하지만 2013년 개발 중단으로 더이상 아무도 사용하지 않는 프레임워크가 되었습니다  \r\n>> 여러요인이 있겠지만 커뮤니티 활성화가 되지 않아 쓰는 사람이 없다가 제가 본 가장 큰요인 이었습니다  \r\n>> kotlin은 이런 측면에서 방대한 커뮤니티를 가지고 있습니다  \r\n>> google은 안드로이드 진형 메인 언어로 Kotlin을 채택하였고 2019년 [google I/O](https://developers-kr.googleblog.com/2019/05/google-io-2019-empowering-developers-to-build-experiences-on-Android-Play.html)에서 다시 한번 언급하였스빈다\r\n>> 또한 jetbrains에서의 지속적인 관리와 피드백이 이루어 졌고 빠르게 전파되어 [Stack OverFlow 2018](https://insights.stackoverflow.com/survey/2018)에서 많은 Love를 획득하였습니다\r\n\r\n![kotlin_love_stackover](/resources/images/2019/kotlin_love_stackover.png)  \r\n<span class=\"img_caption\">source [Stack Overflow](https://insights.stackoverflow.com/survey/2018)</span>\r\n\r\n방대한 커뮤니티를 가지고 있다는 것은 많은 발전의 피드백이 이루어진다는 말이고 이는 분명한 장점으로 작용합니다  \r\ngradle에서 사용하는 groovy언어는 편리하지만 커뮤니티가 형성이 안되었고 개발툴등의 발전 부재로 gradle은 멀티언어로 kotlin을 채택해서 지원하기 시작했습니다\r\n\r\n---\r\n\r\n## 4. 멀티 플랫폼 지원  \r\n>> kotlin만 사용하여 java만 대체해서 개발할 수 있는게 아닙니다   \r\n>> 위에서 언급했듯이 gradle도 kotlin으로 언어를 확장해서 지원하기 시작했습니다   \r\n>> 또한 kotlin만으로 javascript, ios등등의 다양한 플랫폼을 구성하고 개발이 가능합니다\r\n\r\n![kotlin_javascript_java](/resources/images/2019/kotlin_javascript_java.png)  \r\n<span class=\"img_caption\">source [Kotlin Blog](https://blog.jetbrains.com/kotlin/2017/11/kotlin-1-2-released/)</span>\r\n\r\n\r\n자세한 멀티 플래폼관련 사항은 [Multiplatform Programming](https://kotlinlang.org/docs/reference/multiplatform.html)에서 확인 하실수 있습니다\r\n\r\n---\r\n\r\n## 5. Lambda와 Scope Functions\r\n>> 위에 여러 이유들이 있지만 제가 생각하는 kotlin을 사용하는 가장 큰 이유입니다   \r\n>> 먼저 `Lambda`부터 살펴 보겠습니다  \r\n\r\n\r\n> **1. Lambda**  \r\n>> lambda는 굉장히 편리합니다  \r\n>> java8 부터 사용할 수 있고 처음에는 느리다는 평이 많았지만 컴파일러가 발전하면서 현재는 기존코드보다도 빠른 성능을 보일때도 있습니다  \r\n>> 하지만 java lambda에는 명확한 제한사항이 있고 저는 이 때문에 java에서 생각보다 lambda식을 많이 사용하지 않았습니다  \r\n>> 그 제한사항은 외부변수 참조에 `final`이 있어야지만 참조가 된다는 것입니다  \r\n>> 이는 java 메모리 구조상 `heap/stack`으로 나뉘는 부분때문에 외부변수를 lambda내에서 copy해서 사용하게 되고 final을 유지시켜야 한다는 것인데 현재 포스팅하는 글에서 내용이 벗어나니 이만 줄이겠습니다  \r\n>> 관련해서 궁금하시면 다음 글들을 참고하시기 바랍니다\r\n\r\n\r\n>>[Understanding Java 8 Lambda final finally variable](https://www.javahabit.com/2016/06/16/understanding-java-8-lambda-final-finally-variable/)   \r\n>>[Why Do Local Variables Used in Lambdas Have to Be Final or Effectively Final?](https://www.baeldung.com/java-lambda-effectively-final-local-variables)\r\n\r\n<br/>\r\n\r\n>> 다시 돌아와서 kotlin은 이러한 제약없이 자유로운 lambda 사용이 가능합니다  \r\n>> 간단한 예제와 함께 보도록 하겠습니다  \r\n\r\n**Java Code <span class='sub_header'>(Lambda)</span>**\r\n```java\r\n\r\npublic static void main(String[] args) {  \r\n  \r\n        List<String> personList = new ArrayList<>(Arrays.asList(\"deokhwa Kim\", \"junghoon Im\", \"jikin Kim\"));\r\n\r\n        /* highlight-range{1-3} */\r\n        personList.forEach(name ->{\r\n            System.out.println(\"person name : \"+name);\r\n        });\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n\r\n> **실행 결과**\r\n```\r\nperson name : deokhwa Kim\r\nperson name : junghoon Im\r\nperson name : jikin Kim\r\n```\r\n\r\n위에 보시는 코드는 일반적으로 설명하는 java의 lambda 예제입니다  \r\n다음과 같이 기본적으로 personList만 가지고 println 할 상황이 얼마나 될까요.. 이런 기능이 필요나 할까요?  \r\n만약 이름을 한줄로 표현하고 싶어서 외부 변수를 두고 합치는 로직을 구현하면 어떻게 될까요?  \r\n\r\n**Java Code <span class='sub_header'>(variable used in lambda expression should be final or effectively final)</span>**  \r\n```java\r\n    public static void main(String[] args) {\r\n\r\n        List<String> personList = new ArrayList<>(Arrays.asList(\"deokhwa Kim\", \"junghoon Im\", \"jikin Kim\"));\r\n\r\n        String allName = null;  //Not Final         /* highlight-line */  \r\n\r\n        /* highlight-start */\r\n        personList.forEach(name ->{\r\n            if(allName == null)         //외부 참조 Error\r\n                allName += \",\"+name;    //variable used in lambda expression should be final or effectively final\r\n            else\r\n                allName = name;\r\n        });\r\n        /* highlight-end */\r\n        System.out.println(\"person name : \"+allName);\r\n    }\r\n```\r\n***다음과 외부 참조는 Error를 불러 일으킵니다***  \r\n\r\n<br/>\r\n\r\n원하는 결과를 보려면 이런식으로 구현해야 합니다  \r\n\r\n**Java Code <span class='sub_header'>(lambda used final variable)</span>**  \r\n```java\r\n    public static void main(String[] args) {\r\n\r\n        List<String> personList = new ArrayList<>(Arrays.asList(\"deokhwa Kim\", \"junghoon Im\", \"jikin Kim\"));\r\n\r\n        final String[] allName = {null};    /* highlight-line */\r\n\r\n        personList.forEach(name ->{\r\n            if(allName[0] != null)\r\n                allName[0] += \", \"+name;\r\n            else\r\n                allName[0] = name;\r\n        });\r\n        System.out.println(\"person name : \"+ allName[0]);\r\n    }\r\n\r\n```\r\n보시는 것 같이 `forEach`문으로 이름을 합치기 위해 불필요한 배열을 생성하고 외부변수를 썼는지 안 쓴건지 하나하나 전부 고려하며 사용해야 합니다  \r\n이럴꺼면 그냥 `for(String name : personList)`를 사용하겠습니다\r\n  \r\n\r\n<br/>\r\n\r\n> **실행 결과**\r\n```\r\nperson name : deokhwa Kim, junghoon Im, jikin Kim\r\n```\r\n\r\n<br/>\r\n\r\n다음으로 kotlin 코드를 보겠습니다  \r\n코틀린은 그냥 외부참조가 가능하므로 직관적으로 사용해도 됩니다  \r\n\r\n**Kotlin Code <span class='sub_header'>(lambda)</span>**  \r\n```kotlin\r\n    public static void main(String[] args) {\r\n\r\n        val personList = listOf(\"deokhwa Kim\", \"junghoon Im\", \"jikin Kim\")\r\n    \r\n        var allName: String? = null\r\n        /* highlight-range{1-4} */\r\n        personList.forEach {\r\n            allName = if (allName.isNullOrEmpty()) it   //외부 참조\r\n                      else \"$allName, $it\"\r\n        }\r\n        println(\"person name : $allName\")\r\n    }\r\n```\r\n`kotlin lambda`는 아무생각없이 `forEach`으로 간단하게 위의 기능을 구현할수 있습니다  \r\n 여기서 또하나의 장점은 java에서 썼던 name -> 같은 불필요한 인자 없이 `it`으로 내부에서 그냥 사용하면 된다는 것입니다  \r\n 물론 `name ->`을 써서 내부 인자변수명을 변경할 수도 있습니다\r\n \r\n<br/>\r\n\r\n> **실행 결과**  \r\n```\r\nperson name : deokhwa Kim, junghoon Im, jikin Kim\r\n```\r\n\r\n<br/>\r\n\r\n> **2. Scope Function**  \r\n>> Scope Function은 Kotlin에서 제공하는 아주 유용한 6개의 함수들입니다\r\n>>>1. T.let  \r\n>>>2. T.run  \r\n>>>3. run  \r\n>>>4. with  \r\n>>>5. T.apply  \r\n>>>6. T.also  \r\n\r\n>> Scope Function은 말그대로 Kotlin에서 범위를 묶어서 처리할때 사용하는 함수들로\r\n\r\n![scope_table](/resources/iamges/2019/scope_table.png)\r\n<span class=\"img_caption\">source [Fatih Coşkun Blog](https://medium.com/@fatihcoskun/kotlin-scoping-functions-apply-vs-with-let-also-run-816e4efb75f5) </span>\r\n\r\n>> scope들은 비슷한 개념들을 가지고 있는 애들도 존재하고 각각의   \r\n>> scope에서 context object가 `this vs it`이냐  \r\n>> scope에서 return value가 `object vs lambda_result`이냐  \r\n>> 다르게 사용되어 집니다  \r\n\r\n![scope_function](/resources/images/2019/scope_function.png)\r\n<span class=\"img_caption\">source [Jose Alcérreca Blog](https://medium.com/androiddevelopers/kotlin-standard-functions-cheat-sheet-27f032dd4326) </span>\r\n해당 이미지는 한눈에 Scope를 확인할 수 있는 간단한 예제들 입니다  \r\n\r\n***지금 부터 Scope Function에 대해 하나하나 설명해 드리겠습니다***\r\n\r\n---\r\n\r\n**1. T.let**  \r\nT.let의 **context object**는 `it` 이고 **return value**는 `lambda result` 입니다  \r\n\r\n**Kotlin Code <span class='sub_header'>(let sample)</span>**\r\n```kotlin\r\nval numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\r\nnumbers.map { it.length }.filter { it > 3 }.let(::println)  //[5, 4, 4]  /* highlight-line */\r\n```\r\n보시는 것같이 앞의 lambda에 대한 마지막 기능부를 구현할 때 사용할 수 있습니다\r\n\r\n```kotlin\r\nval str: String? = \"Hello\"   \r\nval length = str?.let { /* highlight-line */\r\n    println(\"let() called on $it\")  //let() called on Hello      \r\n    it.length\r\n}\r\nprintln(length) //5  /* highlight-line */\r\n```\r\n`?.`으로 null check를 한뒤 null이 아닐때 기능을 구현하는 코드로도 사용 가능합니다  \r\n반환되는 값은 lambda로 length에는 `\"Hello\".length`의 값이 들어가게 됩니다   \r\n\r\n---\r\n\r\n**2. T.run**  \r\nT.run의 **context object**는 `this` 이고 **return value**는 `lambda result` 입니다  \r\n\r\n**Kotlin Code <span class='sub_header'>(T.run sample)</span>**\r\n```kotlin\r\nval name = \"deokhwa kim\"\r\n/* highlight-range{1-3} */\r\nname.run{\r\n    println(length) //11\r\n    println(name.length) //11\r\n}\r\n```\r\nrun은 계속해서 객체내부의 요소를 사용할때 다음과 같이 사용하실 수 있습니다  \r\n만약 java로 구현한다면 계속해서 `name.`을 써주어야 하지만 kotlin에서는 run이라는 범위로 묶어서 java의 `class내부`의 `this`처럼 간단히 사용하실 수 있습니다  \r\n\r\n---\r\n\r\n**3. run**  \r\nrun의 **context object**는 `this` 이고 **return value**는 `lambda result` 입니다  \r\n해당 run은 위에 T.run과 달리 결과를 묶어서 처리하고 반환값을 받을 때 유용합니다  \r\n\r\n**Kotlin Code <span class='sub_header'>(run sample)</span>**\r\n```kotlin\r\nval name = run{ \r\n    val firstName = \"deokhwa\"\r\n    val lastName = \"kim\"\r\n    \"$firstName $lastName\"  //return /* highlight-line */  \r\n}\r\nprintln(name) //deokhwa kim\r\n```\r\n이 예제는 run으로 묶어서 작업을 처리하고 value를 return 받는 예제입니다\r\n\r\n<br/>\r\n\r\n```kotlin \r\nvar name : String? = null\r\n    name?.let{\r\n        //Null이 아닐때 기능구현\r\n    /* highlight-range{1-3} */  \r\n    } ?: run{  \r\n        //name이 Null일때 기능 구현\r\n    }   \r\n```\r\nlet와 run을 같이 사용하여 다음과 같은 flow도 구현 가능합니다\r\n\r\n<br/>\r\n\r\n```kotlin\r\nval personList = listOf(\"deokhwa Kim\", \"junghoon Im\", \"jikin Kim\")\r\nrun loop@{ /* highlight-line */\r\n    personList.forEach{\r\n        println(it) //deokhwa Kim\r\n        if(it == \"deokhwa Kim\")\r\n            return@loop  //break run /* highlight-line */  \r\n    }\r\n}\r\n```\r\n다음과 같이 forEach에서는 break문을 쓸수 없는데 `run`으로 묶어서 `return@loop`해서 `break`와 같은 기능을 지원하기도 합니다  \r\n만약 그냥 return을 하게되면 메서드가 return되고 `continue`랑 같은 기능을 하려면 `return@forEach`을 사용해야 합니다  \r\n\r\n---\r\n\r\n**4. with**  \r\nwith의 **context object**는 `this` 이고 **return value**는 `lambda result` 입니다   \r\nwith은 T.run과 똑같지만 content object를 파라미터로 받습니다  \r\n\r\n**Kotlin Code <span class='sub_header'>(with sample)</span>**\r\n```kotlin\r\nval name = \"deokhwa kim\"\r\n/* highlight-range{1-3} */\r\nwith(name){\r\n    println(length) //11\r\n    println(name.length) //11\r\n}\r\n\r\n```\r\n\r\n---\r\n\r\n**5. apply**  \r\napply의 **context object**는 `this` 이고 **return value**는 `object` 입니다   \r\n\r\n**Kotlin Code <span class='sub_header'>(apply sample)</span>**\r\n```kotlin\r\ndata class Person(var name: String, var age: Int = 0, var city: String = \"\") //dto class\r\nfun main() {\r\n    /* highlight-range{1-3} */\r\n    val adam = Person(\"Adam\").apply {\r\n        age = 32    //java is adma.setAge(32)\r\n        city = \"London\" //java is adma.setCity(\"London\")        \r\n    }\r\n    println(adam) //Person(name=Adam, age=32, city=London)\r\n}\r\n```\r\napply이는 변수 내부의 값을 주입할때 `object.variable`으로 계속해서 같은 코드를 반복해야 할때 `apply`로 묶어서 `variable`만으로 값을 넣을 수 있습니다 \r\n\r\n\r\n---\r\n\r\n**6. also**  \r\nalso의 **context object**는 `it` 이고 **return value**는 `object` 입니다   \r\n\r\n**Kotlin Code <span class='sub_header'>(apply sample)</span>**\r\n```kotlin\r\ndata class Person(var name: String, var age: Int = 0, var city: String = \"\") //dto class\r\nfun main() {\r\n    /* highlight-range{1-3} */\r\n    val adam = Person(\"Adam\").also {\r\n        it.age = 32    //java is adma.setAge(32)\r\n        it.city = \"London\" //java is adma.setCity(\"London\")        \r\n    }\r\n    println(adam) //Person(name=Adam, age=32, city=London)\r\n}\r\n```\r\nalso는 일반적으로 객체에 사용하면 apply와 같으며 content object만 this에서 it으로 바뀐형태와 같습니다\r\n\r\n<br/>\r\n\r\n```kotlin\r\nval numbers = mutableListOf(\"one\", \"two\", \"three\")\r\nnumbers\r\n    /* highlight-range{1-2} */  \r\n    .also { println(\"The list elements before adding new one: $it\") }\r\n    .add(\"four\")\r\nprintln(numbers) //[one, two, three, four]\r\n```\r\n다음과 같이 lambda로 사용하였을때, 이후 다음 과정을 추가할 수 있다는게 apply와 다른 개념입니다\r\n\r\n---\r\n\r\n## 마무리  \r\n이외에도 kotlin의 장점은 설명하자면  \r\n>1. [Null Safe Programing](https://kotlinlang.org/docs/reference/null-safety.html)  \r\n>2. [Switch기능을 확장한 When](https://kotlinlang.org/docs/reference/control-flow.html#when-expression)  \r\n>3. [편리한 함수 참조의 Kclass](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)  \r\n>4. [Function Default Parameter](https://kotlinlang.org/docs/reference/coding-conventions.html#default-parameter-values)  \r\n>5. [Data Class](https://kotlinlang.org/docs/reference/data-classes.html#data-classes)  \r\n\r\n등등한도 끝도 없이 많아서 이만 마무리를 하려고 합니다  \r\n\r\n<br/>\r\n\r\n처음에는 kotlin의 문법을 배우면서 하나하나 coding 하면서 많은 어려움을 느꼈습니다  \r\njava랑 완벽히 호환된다지만 `서드파티`들간의 호환문제도 있었고 `Assignment not allow in while expression?`라면서 error가 나는 부분 그리고 `Null Safe`조건으로 하나의 변수타입의 속성이 2가지가 존재한다는 개념으로 코딩할때 마다 red_line이 떴습니다  \r\n그럼에도 꾸역꾸역 kotlin으로 프로젝트를 진행하고 보니 이제는 Null Safe으로 코딩하면서 자동으로 얻게 되는 `안정성`과 kotlin의 `생산성`과 `간편함`에 빠져들었습니다  \r\n현재는 java보다 kotlin을 사용한 기간이 압도적으로 짧음에도 불구하고 kotlin이 더욱 편합니다  \r\n이 처럼 많은 분들이 kotlin의 장점을 저처럼 경험하실 수 있었으면 좋겠습니다\r\n\r\n---\r\n\r\n## 부록\r\n\r\n**1. Lombok을 대체할 Kotlin의 사용**\r\n[Migrating from Lombok to Kotlin](https://www.jworks.io/migrating-from-lombok-to-kotlin/)  \r\n\r\n<br/>\r\n\r\n**Java Code <span class='sub_header'>(@Cleanup sample)</span>**\r\n```java\r\n    @Cleanup /* highlight-line */  \r\n    BufferedReader br = new BufferedReader(new FileReader(new File(\"...\")));\r\n```\r\n\r\n<br/>\r\n\r\n**Kotlin Code <span class='sub_header'>(use sample)</span>**\r\n```kotlin\r\n    File(\"...\").bufferedReader().use { /* highlight-line */  \r\n    }\r\n```\r\n서드파티중 가장 많은 부분에서 사용됐던 lombok을 kotlin에서 어떻게 대체하고 있는지를 보여줍니다\r\n\r\n<br/>\r\n<br/>\r\n\r\n**2. While안에 식으로 error가 났던 Kotlin**\r\n[Assignment not allow in while expression?](https://discuss.kotlinlang.org/t/assignment-not-allow-in-while-expression/339)  \r\n\r\n<br/>\r\n\r\n**Java Code <span class='sub_header'>(@Cleanup sample)</span>**\r\n```java\r\n    @Cleanup\r\n    BufferedReader br = new BufferedReader(new FileReader(new File(\"...\")));\r\n    \r\n    String str;\r\n    while((str = br.readLine())!=null){ //kotlin error  /* highlight-line */  \r\n    }\r\n```\r\n\r\n**Kotlin Code <span class='sub_header'>(use sample)</span>**\r\n```kotlin\r\n    File(\"...\").bufferedReader().use { \r\n        while(true){\r\n            val str = it.readLine() ?: break  /* highlight-line */  \r\n        }\r\n    }\r\n```\r\nwhile문안에 식을 썼을때 `가독성`이 떨어진다는 이유로 해당문법을 앞으로도 허용하지 않을꺼라고 합니다  ","fields":{"slug":"/why_kotlin/"},"frontmatter":{"title":"[Kotlin] 왜 Kotlin을 써야 할까?","published":true}}},{"node":{"rawMarkdownBody":"\r\n# 데코레이터 패턴 <span class=\"sub_header\">(Decorator Pattern)</span>\r\n\r\n데코레이터 패턴은 유연한 확장을 지원하는 패턴으로 무언가를 첨가해서 계속해서 장식(decoration)할 때 사용할 수 있는 패턴입니다  \r\n원리는 간단합니다 재귀적인 방법으로 클래스를 덫 씌우면서 장식을 추가 합니다\r\n\r\n![decorator_pattern](/resources/images/2019/decorator_pattern.png)\r\n\r\n<span class=\"img_caption\">출처 : [위키피디아](https://en.wikipedia.org/wiki/Decorator_pattern) </span>\r\n\r\n---\r\n\r\n## Decorator Pattern Sample Code\r\n***카페에서 커피를 주문한다고 할때, 우유, 흑당등을 첨가하는 코드입니다***\r\n\r\n<br/>\r\n\r\n#### Caffee Code\r\n```java\r\n\r\n//커피 인터페이스 구현\r\npublic interface Coffee {\r\n    /* highlight-range{1-2} */\r\n    public double getCost(); //가격  \r\n    public String getIngredients(); //추가된 재료  \r\n}\r\n\r\n\r\n//Interface 구현\r\npublic class SimpleCoffee implements Coffee {\r\n    @Override\r\n    public double getCost() {       \r\n        return 1100;\r\n    }\r\n\r\n    @Override\r\n    public String getIngredients() {  \r\n        return \"Americano\";\r\n    }\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n\r\n#### Decorator Code\r\n```java\r\n\r\npublic abstract class CoffeeDecorator implements Coffee {\r\n    private final Coffee decoratedCoffee;\r\n\r\n    public CoffeeDecorator(Coffee coffee) {\r\n        this.decoratedCoffee = coffee;\r\n    }\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return decoratedCoffee.getCost();\r\n    }\r\n\r\n    @Override\r\n    public String getIngredients() {\r\n        return decoratedCoffee.getIngredients();\r\n    }\r\n}\r\n\r\n//CoffeeDecpratpr 상속\r\nclass Milk extends CoffeeDecorator {\r\n\r\n    public WithMilk(Coffee coffee) {\r\n        super(coffee);\r\n    }\r\n\r\n    @Override\r\n    public double getCost() { // Overriding methods defined in the abstract superclass\r\n        return super.getCost() + 300;\r\n    }\r\n\r\n    @Override\r\n    public String getIngredients() {\r\n        return super.getIngredients() + \", 우유\";\r\n    }\r\n}\r\n\r\n//CoffeeDecpratpr 상속\r\nclass BlackSugar extends CoffeeDecorator {\r\n\r\n    public BlackSugar(Coffee coffee) {\r\n        super(coffee);\r\n    }\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return super.getCost() + 500;\r\n    }\r\n\r\n    @Override\r\n    public String getIngredients() {\r\n        return super.getIngredients() + \", 흑당\";\r\n    }\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n\r\n#### Main Code\r\n```java\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Coffee coffee = new SimpleCoffee();      //기본 아메리카노\r\n        System.out.println(\"가격 : \"+coffee.getCost()+\"원 / 메뉴 : \"+coffee.getIngredients())\r\n\r\n        coffee = new Milk(coffee);    //우유 추가\r\n        System.out.println(\"가격 : \"+coffee.getCost()+\"원 / 메뉴 : \"+coffee.getIngredients())\r\n\r\n        coffee = new BlackSugar(coffee);   //흑당 추가\r\n        System.out.println(\"가격 : \"+coffee.getCost()+\"원 / 메뉴 : \"+coffee.getIngredients())\r\n    }\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n#### 실행화면\r\n```java\r\n\r\n가격 : 1100원 / 메뉴 : Americano\r\n가격 : 1400원 / 메뉴 : Americano, 우유\r\n가격 : 1900원 / 메뉴 : Americano, 우유, 흑당\r\n\r\n```","fields":{"slug":"/decorator_pattern/"},"frontmatter":{"title":"[DesignPattern] Decorator Pattern","published":true}}},{"node":{"rawMarkdownBody":"\r\n# K-평균 <span class=\"sub_header\">(K-mean cluster)</span>\r\n***데이터를 k개의 클러스터로 묶는 알고리즘***\r\n\r\n이 알고리즘을 데이터를 K개의 그룹으로 묶고 싶을때 사용하는 알고리즘 중 하나입니다\r\n방법은 간단합니다\r\n\r\n![K-means](/resources/images/2019/Kmeans.gif)\r\n\r\n<span class=\"sub_header\">\r\n\r\n출처 : [위키피디아](https://ko.wikipedia.org/wiki/K-%ED%8F%89%EA%B7%A0_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98) \r\n\r\n</span>\r\n\r\n\r\n> **K-mean 알고리즘 방식** \r\n>> 1. k개의 점을 잡는다  \r\n>> 2. 데이터들을 가장 가까운 k개의 점으로 묶는다  \r\n>> 3. k점들을 묶은 데이터를 기반으로 중심점으로 이동시킨다  \r\n>> 4. 2~3의 과정을 묶음이 변화가 없을 때까지 반복한다  \r\n\r\n\r\n---\r\n\r\n## K-mean Sample\r\n\r\n<br/>\r\n\r\n#### Scikit-Learn K-mean Code\r\n```python\r\n\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom sklearn.cluster import KMeans\r\n\r\n\r\nX = np.array([[5,3],\r\n     [10,15],\r\n     [15,12],\r\n     [24,10],\r\n     [30,45],\r\n     [85,70],\r\n     [71,80],\r\n     [60,78],\r\n     [55,52],\r\n     [80,91],])\r\n\r\n\r\nif __name__ == \"__main__\":\r\n     kmeans = KMeans(n_clusters=3)  //3개의 군집 형성\r\n     kmeans.fit(X)\r\n\r\n     print(kmeans.labels_)  //라벨로 군집을 확인 할 수 있습니다\r\n\r\n     plt.scatter(X[:,0],X[:,1], c=kmeans.labels_, cmap='rainbow')\r\n     plt.show()\r\n\r\n\r\n```\r\n\r\n<br/>\r\n\r\n####실행화면\r\n```\r\n[1 1 1 1 2 0 0 0 2 0]\r\n```\r\n\r\n![kmean_result](/resources/images/2019/kmean_show.png)\r\n\r\n<br/>\r\n\r\n#### K점 확인하기\r\n```python\r\n\r\n     plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], color='black')\r\n\r\n```\r\n***plt에 다음줄을 추가하여 K점을 확인 할 수 있습니다***\r\n\r\n<br/>\r\n\r\n####실행화면\r\n\r\n![kmean_result2](/resources/images/2019/kmean_show2.png)\r\n\r\n---\r\n## 마무리\r\n간단하게 K-mean 알고리즘에 대해 알아 봤습니다  \r\n알고리즘을 보시면 알겠지만 데이터의 차원수와 처음 k 기준점의 생성 위치에 따라 군집이 달라질 수 있습니다  \r\nk 기준점 선정에 대해서 많은 사람들이 관련 연구를 진행하였고 다양한 초기화 기법도 나왔습니다  \r\n해당 포스팅에는 작성하지 않았습니다 혹시 필요하신분은 [위키피디아-K평균 알고리즘](https://ko.wikipedia.org/wiki/K-%ED%8F%89%EA%B7%A0_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)을 참고하시기 바랍니다  \r\n\r\n대규모 데이터와 같은 곳에서 사용하면 이쁘고 유용한 결과를 얻을 수 있습니다\r\n\r\n![k평균](/resources/images/2019/k-mean.png)  \r\n\r\n위 그래프는 실제 제가 회사 데이터를 K평균으로 분류하여 유용한 데이터들입니다  \r\nScikit-Learn을 사용하면 간편하고 사용해보실 수 있으니 분석하실 데이터의 군집화가 필요하시다면 사용해 보시기 바랍니다  \r\n그리고 만약 군집화를 정해진 개수 없이 하고 싶으시면 Label Propagation 알고리즘을 사용해 보시기 바랍니다","fields":{"slug":"/k_mean_algorithm/"},"frontmatter":{"title":"[Algorithm] K-mean","published":true}}},{"node":{"rawMarkdownBody":"\r\n# 전략 패턴 <span class=\"sub_header\">(Strategy Pattern)</span>\r\n***메인 프로세스에서 상황에 맞게 전략을 선택하여 실행하는 패턴입니다***  \r\n\r\n![strategy_pattern](/resources/images/2019/Strategy_Pattern.png)\r\n<span class=\"img_caption\">출처 : [위키피디아](https://ko.wikipedia.org/wiki/%EC%A0%84%EB%9E%B5_%ED%8C%A8%ED%84%B4) </span>\r\n\r\n<br/>\r\n\r\n이 패턴은 가장 기본적이며 인터페이스의 필요여부를 가장 잘 보여 주고 많은 곳에서 사용하고 있는 패턴입니다  \r\n이 그림에서 볼 수 있듯이 하나의 인터페이스를 두고 클래스들이 인터페이스를 구현하여 사용됩니다  \r\n\r\n---\r\n\r\n## Strategy Sample\r\n\r\n</br>\r\n\r\n#### StrategyInterface\r\n```\r\npublic interface Strategy {\r\n    public void execute();\r\n}\r\n\r\n```\r\n<br/>\r\n\r\n#### ContentsStrategyA &nbsp;<span calss=\"sub_header\"></span>\r\n```java\r\npublic class ContentsStrategyA implements Strategy{\r\n    @Override\r\n    public void execute() {\r\n        System.out.println(\"앞으로 이동\");\r\n    }\r\n}\r\n\r\n```\r\n<br/>\r\n\r\n#### ContentsStrategyB &nbsp;<span calss=\"sub_header\"></span>\r\n```java\r\npublic class ContentsStrategyB implements Strategy{\r\n    @Override\r\n    public void execute() {\r\n        System.out.println(\"뒤로 이동\");\r\n    }\r\n}\r\n```\r\n<br/>\r\n\r\n#### Main\r\n```java\r\n\r\n@SpringBootApplication\r\npublic class SimpleCode{\r\n\r\n    //Run\r\n    public void robot() {\r\n    \r\n        //전략 리스트\r\n        List<String> moveList = Arrays.asList(\"go\", \"back\", \"go\", \"go\");\r\n        List<Strategy> strategyList = new ArrayList<>();\r\n\r\n        moveList.forEach(m -> {\r\n            switch (m) {\r\n                case \"go\":\r\n                    strategyList.add(new ContentsStrategyA());  //기능 A\r\n                    break;\r\n                case \"back\":\r\n                    strategyList.add(new ContentsStrategyB());  //기능 B\r\n                    break;\r\n            }\r\n        });\r\n\r\n        strategyList.forEach(Strategy::execute);  //기능 실행\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n\r\n#### 실행결과\r\n```\r\n앞으로 이동\r\n뒤로 이동\r\n앞으로 이동\r\n앞으로 이동\r\n\r\n```\r\n\r\n<br/>\r\n\r\n위에 code를 보시면 먼저 **StrategyInterface** 인터페이스를 구현합니다  \r\n그리고 각각의 기능을 **ContentsStrategyA**, **ContentsStrategyB**에서 구현하게 됩니다  \r\n그러면 메인프로세스는 **StrategyInterface**만으로 각각의 상황에 맞춰 전략을 선택하고 실행 할 수 있습니다\r\n","fields":{"slug":"/strategy_pattern/"},"frontmatter":{"title":"[DesignPattern] Strategy Pattern","published":true}}},{"node":{"rawMarkdownBody":"\r\n#사건의 발단\r\n\r\n얼마전 Reactive Programing을 공부하면서 [백기선님의 유튜브](https://www.youtube.com/channel/UCwjaZf1WggZdbczi36bWlBA)를 보다 문득 의문이 생기는 부분이 있었습니다\r\n\r\n```textbox\r\nBy being built around the core pillars of being fully asynchronous and non-blocking,  \r\nReactive Programming is an alternative to the more limited ways of doing asynchronous code in the JDK: namely Callback based APIs and Future.\r\n```\r\n***\"asynchronous하면 당연히 non-blocking 되는 게 아닌가?\"*** &nbsp;지금까지 저는 비동기면 당연히 논블록킹하다고 생각하고 있었습니다   \r\n그래서 알아보게 되었습니다  \r\n\r\n---\r\n\r\n## 동기(Synchronous)와 비동기(Asynchronous)  \r\n***호출된 메서드를 호출하는 쪽에서 관심을 가지고 있는지 봅니다***\r\n\r\n> **1. 동기(Synchronous)**\r\n>> 호출되는 기능의 완료를 호출한 쪽에서 확인하고 처리한다  \r\n>> 단순히 기능의 완료를 호출하는 쪽에서 관심을 보이면 동기로 보면 됩니다  \r\n>> `일반적인 함수 호출`이 여기에 해당됩니다  \r\n\r\n> **2. 비동기(Asynchronous)**\r\n>> 호출되는 기능의 완료를 호출 한 쪽에서 알아서 처리하는 것  \r\n>> 호출하는 쪽에서 비동기로 호출한다는건 해당 기능의 완료가 어떻게 되든 신경쓰지 않는다는 겁니다  \r\n>> 호출된쪽에서는 `callback`을 통해 완료를 전달하게 됩니다  \r\n\r\n\r\n---\r\n\r\n## 블로킹(Blocking)과 논블로킹(NonBlocking)  \r\n***메인 프로세스 플로우의 제어권에 초점을 맞추고 있습니다***\r\n\r\n> **1. 블로킹(Blocking)**\r\n>> 메인 플로우의 제어권이 호출된 쪽으로 넘어가서 해당 제어권을 다시 돌아오기를 기다립니다    \r\n>> 기다리는 동안 메인 플로우는 제어권을 상실하여 아무것도 하지 않습니다  \r\n\r\n> **2. 논블로킹(NonBlocking)**\r\n>> 메인 플로우가 제어권을 바로 반환 받습니다  \r\n>> 메인 플로우는 제어권을 가지고 있으므로 얼마든지 본인의 플로우대로 작업을 실행합니다  \r\n\r\n\r\n---\r\n\r\n## 같이 생각하기  \r\n\r\n***이제 동기와 비동기 & 블로킹과 논블로킹을 같이 생각해 보겠습니다***  \r\n\r\n\r\n![developer_works_metrix](/resources/images/2019/developer_works_metrix.png)\r\n\r\n<span class=\"img_caption\"> 출처 : [Homo Efficio님 블로그](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/) </span>\r\n\r\n<br/>\r\n\r\n그림으로 보면 다음과 같습니다  \r\n2 x 2로 해당 개념들을 믹스해보면 다음과 같습니다\r\n\r\n- Sync-Blocking\r\n- Sync-NonBlocking\r\n- Async-Blocking\r\n- Async-NonBlocking\r\n\r\n그럼 하나하나 차근차근 살펴 보겠습니다\r\n\r\n---\r\n\r\n## 동기 블로킹 (Sync_Blocking)\r\n***메인 프로세스에서 제어권이 넘어가서 작업이 끝나고 제어권을 다시 받는다***\r\n\r\n일반적인 순서대로 호출되는 함수 호출이 Sync_Blocking 입니다\r\n\r\n#### Sample Source\r\n```java\r\n\r\n@SpringBootApplication\r\npublic class SimpleCode{\r\n\r\n    private int sum(int a, int b) {\r\n        return a + b;\r\n    }\r\n\r\n    //Run\r\n    public void syncBlockTest() {\r\n        System.out.println(\"1 + 1 = \" + sum(1, 1));     //제어권이 Sum 메서드로 넘어갑니다\r\n        System.out.println(\"1 + 1 = 귀요미지..\");\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n1 + 1 = 2\r\n1 + 1 = 귀요미지..\r\n\r\n```\r\n\r\n<br/>\r\n\r\n제어권이 sum 메서드로 넘어가며 블로킹 되었고 syncBlockTest는 제어권을 잃어서  \r\n`1 + 1 = 귀요미지..`를 호출하지 않고 기다렸다가 **순차적**으로 실행 되었습니다\r\n\r\n---\r\n\r\n## 동기 논블로킹 (Sync_NonBlocking)\r\n***메인 프로세스에서 제어권이 넘겼다가 바로 받지만 호출된 기능의 완료에 관심을 보입니다***\r\n\r\n**그림을 다시한번 보시겠습니다**\r\n\r\n![sync_nonBlocking](/resources/images/2019/sync_nonBlocking.png)\r\n\r\n<span class=\"img_caption\"> <b> Sync_NonBlocking </b> </span>\r\n\r\n\r\n여기서 부터 애매해서 많이들 어려워하는 부분입니다  \r\n~~하지만 걱정하지 마세요 Sync_NonBlocking은 일반적이지 않습니다~~  \r\n\r\n#### Sample Source\r\n```java\r\n\r\n@Async\r\n@Service\r\npublic class AsyncCodeTest {\r\n    @Async  //Async로 비동기 논블로킹이 자동으로 구현되기 때문에 헷갈리기 쉽습니다\r\n    public Future<Integer> asyncSum(int a, int b) throws Exception{\r\n        Thread.sleep(1000);\r\n        return new AsyncResult<>(a+b);\r\n    }\r\n}\r\n\r\n\r\n@EnableAsync\r\n@SpringBootApplication\r\npublic class SimpleCode {\r\n\r\n    //Run\r\n    public void syncNonBlockTest() throws Exception {\r\n        Future<Integer> sumResult = asyncCodeTest.asyncSum(1,1); //제어권을 바로 반환 받습니다(NonBlocking)\r\n        while(!sumResult.isDone()){  //메인 프로세스는 주기적으로 asyncSum의 완료를 확인 합니다(핵심)\r\n            System.out.println(\"1 + 1 = 귀요미지..\");  //asyncSum과 상관없이 메인 프로세스가 자리 일을 합니다           \r\n        }\r\n        System.out.println(\"1 + 1 = \" + sumResult.get());  //asyncSum의 호출을 이미 isDone()으로 알고 있습니다\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n.....\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 2\r\n```\r\n\r\n<br/>\r\n\r\n이부분을 이해하는데 있어서 많이 어려웠던거 같습니다  \r\n@Async면 async지 왜.. sync야 라고 생각하게 되었고 보면 볼수록 더 헷갈리게 되는 개념이었습니다  \r\n\r\n####하지만 판별의 핵심은\r\n> **1. 제어권의 판별**\r\n>> 제어권이 메인 프로세스로 부터 (거의)이관되어 지지 않음 = NonBlocking  \r\n \r\n> **2. 관심의 판별**  \r\n>> 메인 프로세스가 asyncSum의 isDone()을 확인하며 완료를 직접 확인함 = sync \r\n\r\n---\r\n\r\n## 비동기 논블로킹 (Async_NonBlocking)\r\n***메인 프로세스에서 제어권이 넘겼다가 바로 받고 호출된 기능의 완료에 관심을 갖지 않습니다***\r\n\r\n원활한 설명을 위해서 비동기 논블로킹부터 설명하겠습니다\r\n호출된 기능의 완료에 관심을 갖지 않는다는 말은 기능이 알아서 완료여부를 반환해서 Pull 해주는 것도 포함됩니다 <span class=\"sub_header\">(callback)</span>\r\n\r\n#### Sample Source\r\n```java\r\n\r\n@Async\r\n@Service\r\npublic class AsyncCodeTest {\r\n    @Async\r\n    public void asyncSum(int a, int b) throws Exception{\r\n        System.out.println(\"1 + 1 = \"+(a+b));\r\n    }\r\n}\r\n\r\n\r\n@EnableAsync\r\n@SpringBootApplication\r\npublic class SimpleCode {\r\n\r\n    //Run\r\n    public void asyncNonBlockTest() throws Exception {\r\n        asyncCodeTest.asyncSum(1,1);    //asyncNonBlockTest은 제어권을 바로 반환 받습니다\r\n        System.out.println(\"1 + 1 = 귀요미지..\");\r\n        Thread.sleep(1000); //메인 프로세스의 다른 작업들 대신 사용하였습니다 \r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n.....\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 2\r\n```\r\n\r\n<br/>\r\n\r\n메인 프로세스는 asyncSum 호출했지만 바로 제어권을 받아서 `1 + 1 = 귀요미지...`를 출력했습니다  \r\n그리고 여기서는 Thread.sleep(1000)을 사용하였지만 메인 프로세스의 작업들이라고 생각해 주시기 바랍니다  \r\n\r\n```textbox\r\nThread.sleep(1000)을 한 이유는 메인프로세스는 asyncSum을 호출 했지만 완료에  \r\n관심을 갖지 않기 때문에 메인 프로세스가 asyncSum() 완료와 상관없이 먼저 종료 될 수 있습니다\r\n\r\n```\r\n<br/>\r\n\r\n#### 한마디더\r\n다른 건 이해하지 못하더라도 async_nonBlocking은 꼭 알아두셔야 합니다  \r\n위에서 언급했지만 async_nonBlocking은 가장 효율적인이며 이상적인 구조입니다  \r\n***Reactive Programing is built around the core pillars of being fully asynchronous and non-blocking***\r\n\r\n---\r\n\r\n## 비동기 블로킹 (Async_Blocking)\r\n***메인 프로세스에서 제어권이 넘어갔지만 호출된 기능의 완료에 관심을 갖지 않습니다***\r\n\r\n**그림을 다시한번 보시겠습니다**\r\n\r\n![async_blocking](/resources/images/2019/async_blocking.png)\r\n\r\n<span class=\"img_caption\"> <b> Async_Blocking </b> </span>\r\n\r\n저에게는 가장 어려운 개념이었습니다  \r\n제어권이 상대에게 있는데 완료에 관심을 갖지 않는다는게 생각되지 않았기 때문입니다  \r\n그래서 결론 내리길 핵심은 콜백을 받는 입장으로 대기한다라고 생각합니다\r\n\r\n\r\n#### Sample Source\r\n```java\r\n\r\n@Async\r\n@Service\r\npublic class AsyncCodeTest {\r\n    @Async\r\n    public Future<Integer> asyncSum(int a, int b) throws Exception{\r\n        Thread.sleep(1000);\r\n        return new AsyncResult<>(a+b);\r\n    }\r\n}\r\n\r\n\r\n@EnableAsync\r\n@SpringBootApplication\r\npublic class SimpleCode {\r\n\r\n    //Run\r\n    public void asyncBlockTest() throws Exception {\r\n        Future<Integer> sumResult = asyncCodeTest.asyncSum(1, 1); //asyncBlockTest은 제어권을 바로 반환 받습니다 -> 여기서는 nonBlocking으로 해석이 가능합니다\r\n        System.out.println(\"1 + 1 = \" + sumResult.get());   //isDone()의 상태를 모르고 get()하여 대기(blocking)합니다 -> async\r\n        System.out.println(\"1 + 1 = 귀요미지..\");\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n1 + 1 = 2\r\n1 + 1 = 귀요미지..\r\n```\r\n\r\n<br/>\r\n\r\n아까와 같은 Future의 get()을 써서 헷갈리실 수 있지만 엄연히 다른 개념으로 보셔야 합니다  \r\n아까는 메인 프로세스가 isDone()으로 asyncSum의 상태를 계속 해서 확인한 반면 지금은 단순히 get()을 호출하고 asyncSum에서 값을 return 할때 까지 단순히 대기 하고 있습니다  \r\n다시말해 get()을 호출하면 메인 프로세스는 blocking되며 asyncSum에서 값이 Pull 되기를 기다리게 됩니다  \r\n조금 쉽게 이야기하면 ***Async_NonBlocking에서 Blocking되는 상황이 생기면 Async_Blocking이 됩니다***  \r\n\r\n\r\n대표적인 예가 JDBC입니다  \r\nJDBC는 blocking 방식으로 DB에 접근하게 되는데 비동기 환경에서 JDBC로 DB에 접근하게 되는 순간 이 프로세스는 **async_blocking**이 되는 것입니다 \r\n\r\n####하지만 판별의 핵심은\r\n> **1. 제어권의 판별**\r\n>> 제어권이 메인 프로세스로 부터 Future의 get()을 호출 하므로 이관되어짐 = Blocking  \r\n \r\n> **2. 관심의 판별**  \r\n>> 메인 프로세스는 asyncSum가 완료되어 Callable로 Futrue의 get()에 값을 주길 기다림 = sync \r\n\r\n---\r\n\r\n## 마무리\r\n저는 동기(Synchronous)와 비동기(Asynchronous) & 블로킹(Blocking)과 논블로킹(NonBlocking)을 이해하면서 많은 어려움이 있었습니다  \r\n이해 했다가도 다시 볼수록 더 헷갈리고 이해가 안되는 부분이 많았습니다  \r\n공부를 하면서 이런저런 자료를 뒤지던중 많은 자료들을 볼 수 있었고 관련 내용에 대한 많은 토론도 볼 수 있었습니다  \r\n그리고 포스팅을 하면서 지금 제가 내린 **결론은 정답은 없다** 입니다  \r\n\r\n위의 예시도 부분부분적으로 코드를 나눠보면 다른 개념들로 충분히 해석되어 질 수 있습니다  \r\n그러므로 해당 개념들을 간단히 보시고 Synchronous의 개념과 Blocking의 개념이 다르구나를 생각해 주시고  \r\n궁긍적으로 ***Asynchronous_NonBlocking***으로 프로그래밍 패러다임이 이동한다는 것에 집중하시는게 더 좋을 꺼 같습니다","fields":{"slug":"/blocking_nonBlocking_synchronous_asynchronous/"},"frontmatter":{"title":"동기(Synchronous)와 비동기(Asynchronous) & 블로킹(Blocking)과 논블로킹(NonBlocking)","published":true}}},{"node":{"rawMarkdownBody":"\r\n# 옵저버 패턴 <span class=\"sub_header\">(Observer Pattern)</span>\r\n\r\n옵저버 패턴은 Java 내부와 Spring Core, Reative Programming의 기본이 되는 패턴입니다\r\n옵저버 디자인 패턴은 기본적으로 `Subject`와 `Observer`를 가지고 있습니다  \r\n\r\n> **1. Subject**\r\n>> Observer의 Manager 개념으로 Observer를 등록하여 특정 이벤트가 발생했을때 관찰자들이 알 수 있도록 해준다  \r\n\r\n> **2. Observer**\r\n>> 실제 관찰자로 이벤트의 따른 기능들이 구현되어 있고, Subject에 등록되었다가 호출되어 진다  \r\n\r\n기본적으로 Observer 인터페이스를 생성해 두고 Observer를 구현해서 Subject의 등록해서 사용합니다  \r\n***한마디로, 여러 기능들을 하나의 인터페이스로 통합해서 Subject의 등록해서 호출하는 로직으로 볼 수 있습니다 <span class=\"sub_header\">(1 대 N관계)</span>***  \r\n\r\n<br/>\r\n\r\n\r\n![observer_pattern](/resources/images/2019/Observer.png)\r\n\r\n<span class=\"img_caption\">출처 : [위키백과 옵서버 패턴](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)</a></span>\r\n\r\n\r\n---\r\n\r\n***이해를 돕기위해 Observer 부터 구현해 보겠습니다***\r\n\r\n### Observer Sample\r\n```java\r\n    /* highlight-range{1-3} */\r\n    public interface Observer<T> {       //옵저버 인터페이스\r\n        void printEvent(T event);\r\n    }\r\n\r\n    public class ObserverEventA implements Observer<String> { \r\n        @Override\r\n        public void printEvent(String event) {\r\n            System.out.println(\"Event : \" + event);  //옵저버 기능\r\n        }\r\n    }\r\n    \r\n```\r\n\r\n<br/>\r\n\r\n### Subject Sample\r\n```java\r\n\r\n    public interface Subject<T> {\r\n        void registerObserver(Observer<T> observer); //옵저버 등록\r\n\r\n        void removeObserver(Observer<T> observer);   //옵저버 삭제\r\n\r\n        void executeObserver(T event);               //옵저버 실행\r\n    }\r\n\r\n\r\n    public class SampleSubject implements Subject<String> {\r\n\r\n        private final Set<Observer<String>> observerSet = new CopyOnWriteArraySet<>();    //Thread Safe Set\r\n\r\n        public void registerObserver(Observer<String> observer) {\r\n            this.observerSet.add(observer);\r\n        }\r\n\r\n        public void removeObserver(Observer<String> observer) {\r\n            this.observerSet.remove(observer);\r\n        }\r\n\r\n        public void executeObserver(String event) {\r\n            this.observerSet.forEach(o -> o.printEvent(event));\r\n        }\r\n    }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n### Observer Run\r\n```java\r\n\r\n    @Test\r\n    public void observerTest(){\r\n\r\n        Subject<String> subject = new SampleSubject();      //observer manager 생성\r\n        \r\n        subject.registerObserver(new ObserverEventA());     //observer 등록\r\n \r\n        subject.registerObserver(event -> {                 //lambda식 등록도 가능합니다\r\n            System.out.println(\"Event : \" + event);\r\n        });         \r\n        \r\n        subject.registerObserver(System.out::println);      //lambda 단순 println\r\n\r\n        subject.executeObserver(\"Observer Run\");            //실행\r\n    }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n> **실행 결과**\r\n```\r\n\r\nEvent : Observer Run\r\nEvent : Observer Run\r\nObserver Run\r\n\r\n```\r\n\r\n---\r\n## 마무리  \r\nJava에서도 JDK1.0에서 Observer와 Observable이 릴리즈되어 사용할 수 있습니다  \r\n하지만 자바 제네릭이 없던 시절이라.. Object타입을 사용해서 안전성이 보장되지 않습니다\r\n그래서 인지 **JDK9 버젼** 부터는 **Deprecated** 되었습니다\r\n\r\n<br/>\r\n\r\n더 나아가 Observer 구현해서 사용 하시기전 다음과 같은 사항을 권고하고 있습니다  \r\n\r\n>**1. 이벤트 모델**\r\n>> Java.beans 패키지 사용으로 구성  \r\n\r\n>**2. 쓰레드간 메시징**\r\n>>java.util.concurrent 패키지에서 동시 데이터 조작 구조를 사용  \r\n\r\n>**3. Reactive Programing**\r\n>> Flow API를 참조하여 구현\r\n\r\n자세한 관련 내용은 [Java's Observer and Observable Are Deprecated in JDK 9](https://dzone.com/articles/javas-observer-and-observable-are-deprecated-in-jd)를 참고 하세요","fields":{"slug":"/observer_pattern/"},"frontmatter":{"title":"[DesignPattern] Observer Pattern","published":true}}},{"node":{"rawMarkdownBody":"\r\n#Spring AOP\r\n\r\n## AOP <span class=\"sub_header\">(Aspect-Oriented Programming)</span>\r\n> AOP는 ***관점 지향 프로그래밍***으로 **핵심 비즈니스 기능과 공통기능을 분리**하여 공통기능의 중복을 없애고 객체들간의 관계 복잡도를 줄이는데 사용된다  \r\n> **위빙(Weaving)**을 통해 핵심기능에서 벗어난 공통기능을 정의하고 사용할 수 있다록 한다  \r\n\r\n이렇게 해서 얻을 수 있는 이점을 크게 두가지이다  \r\n```textbox\r\n1. 요청으로 부터 핵심기능으로 접근하는 방법을 제어하기 위해\r\n2. 핵심기능에 대해서 추가적인 기능을 주여해주기 위해\r\n```\r\n\r\n---\r\n## Spring AOP\r\n>Spring에서는 **Proxy**를 이용하여 AOP서비스를 제공한다  \r\n\r\n**1. JDK 동적 프록시**\r\n>>java 리플렉션을 이용하여 개체를 만드는 프록시\r\n\r\n**2. CGLIB 프록시**\r\n>> 바이트 코드를 조작하여 만드는 프록시\r\n\r\n_예전에는 AOP를 위해 interface를 구현해야 했지만, Spring3.2부터 CGLIB가 Spring core에 포함되면서 필요없어 졌다_\r\n\r\n![spring_aop_proxy](/resources/images/2019/spring_aop_proxy.png)  \r\nAOP Object는 마치 자신인 핵심 Core Object처럼 꾸며서 흐름을 제어한다 \r\n\r\n---\r\n###Spring AOP를 사용하기 위한 주요 요건\r\n- **Aspect <span class=\"sub_header\">(@Aspect)</span>**\r\n>>공통 관심사를 모듈화 한 자바 클래스\r\n- **Advice <span class=\"sub_header\">(@Advice)</span>**\r\n>>무엇(What)이 실행될 것인지의 공통기능담은 구현체를 의미\r\n- **Pointcut <span class=\"sub_header\">(@Pointcut)</span>**\r\n>>어디에서(Where) Advice를 실행할 것인지를 정의\r\n\r\n<br/>\r\n\r\n###Advice  \r\n>>1. **Before** : 메서드 호출 이전  \r\n>>2. **After** : 메서드 호출 이후  \r\n>>3. **AfterReturning** : 메서드가 예외없이 실행된 이후  \r\n>>4. **AfterThrowing** : 메서드에 예외가 발생한 이후  \r\n>>5. **Around** : 메서드의 실행 전/후   \r\n\r\n<br/>\r\n\r\n###Pointcut\r\n\r\n<div class=\"table-wrapper\" markdown=\"block\">\r\n\r\nPointcut|Joinpoints\r\n-----|-----\r\nexecution(public * *(..))|public 메소드 실행\r\nexecution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행\r\n|execution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행|\r\n|execution(* com.xyz.service.AccountService.*(..))|AccountService 인터페이스의 모든 메소드 실행|\r\n|execution(* com.xyz.service.*.*(..))|service 패키지의 모든 메소드 실행|\r\n|execution(* com.xyz.service..*.*(..))|service 패키지와 하위 패키지의 모든 메소드 실행|\r\n|within(com.xyz.service.*)|service 패키지 내의 모든 결합점 (클래스 포함)|\r\n|within(com.xyz.service..*)|service 패키지 및 하위 패키지의 모든 결합점 (클래스 포함)|\r\n|this(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 프록시 개체의 모든 결합점|\r\n|target(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 대상 객체의 모든 결합점|\r\n|args(java.io.Serializable)|하나의 파라미터를 갖고 전달된 인자가 Serializable인 모든 결합점|\r\n|@target(org.springframework.transaction.annotation.Transactional)|대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@within(org.springframework.transaction.annotation.Transactional)|대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@annotation(org.springframework.transaction.annotation.Transactional)|실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@args(com.xyz.security.Classified)|단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점|\r\n|bean(accountRepository)|“accountRepository” 빈|\r\n|!bean(accountRepository)|“accountRepository” 빈을 제외한 모든 빈|\r\n|bean(*)|모든 빈|\r\n|bean(account*)|이름이 'account'로 시작되는 모든 빈|\r\n|bean(*Repository)|이름이 “Repository”로 끝나는 모든 빈|\r\n|bean(accounting/*)|이름이 “accounting/“로 시작하는 모든 빈|\r\n|bean(*dataSource)  bean(*DataSource)|이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈|\r\n\r\n</div>\r\n\r\n<span class=\"sub_header\">출처 : [얼청뚱땅 개발자 블로그](https://devjms.tistory.com/70)</span>\r\n\r\n<br/>\r\n\r\n###Simple Source\r\n\r\n<br/>\r\n\r\n***SpringBootApplication***\r\n```java\r\n\r\n@EnableAspectJAutoProxy //AOP 활성화\r\n@SpringBootApplication\r\npublic class SpringBootTestApplication implements CommandLineRunner {\r\n    ...\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SpringBootTestApplication.class, args);\r\n    }\r\n    \r\n    @Override\r\n    public void run(String... args) throws Exception {\r\n        simpleSource.test();\r\n    }\r\n    ...\r\n }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n***AopClass***\r\n```java\r\n@Slf4j\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    @Before(\"execution(* com.service.SimpleSource.test(..))\")\r\n    public void aopBefore(){\r\n        log.info(\"aop before\");\r\n    }\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Recycle***\r\n\r\n```java\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    @Pointcut(\"execution(* *.*(..))\")\r\n    private void logging(){}\r\n    \r\n    @Around(\"logging()\")\r\n    public void aopBefore(){\r\n        log.info(\"aop around\");\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Exclude***\r\n\r\n```java\r\n\r\n@Service\r\npublic class SimpleSource {\r\n    ...\r\n    @NoLogging\r\n    public void logNo(){\r\n       ...\r\n    }\r\n    ...\r\n}\r\n-------------------------------------------------------\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    \r\n    @Pointcut(\"execution(* *.*(..)) && !@target(com.annotation.NoLogging)\")\r\n    private void logging(){}\r\n    \r\n    ...\r\n}\r\n```\r\n*annotation을 구현해서 pointcut에 예외처리 지정하기*\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/spring_aop/"},"frontmatter":{"title":"Spring AOP","published":true}}},{"node":{"rawMarkdownBody":"<figure class=\"float_left\">\r\n\t<img src=\"/images/profile.jpg\" alt=\"profile\">\r\n</figure>\r\n\r\n<div class=\"float_left_content\">\r\n\r\n#Deokhwa Kim <sapn class=\"sub_header\">renuevo0110@gmail.com</span> \r\n*1992.01.10*\r\n\r\n**< Data Service Developer>**  \r\n*사람인HR LAB에 근무중*  \r\n평소에 **Spring**으로 개발하며 요즘은 **Java**대신 주로 **Kotlin**으로 개발하고 있습니다    \r\n최근 관심사는 Reactive Programing과 MSA 입니다\r\n\r\n</div>\r\n\r\n<p class=\"clear_float\"></p>\r\n\r\n---\r\n\r\n![dev_life](/resources/images/2019/profile_dev_life.jpg)","fields":{"slug":"/profile/"},"frontmatter":{"title":"Profile","published":true}}},{"node":{"rawMarkdownBody":"\r\n# LTR <span class=\"sub_header\">(Learning To Rank)</span>\r\n\r\n#### 스코어 정렬에 머신러닝 알고리즘을 사용\r\n```textbox\r\n\r\nTF-IDF와 BM25가 검색결과를 도출하는 하고 상관없는 문서를 빼는것에 초점을 둔 반면 LTR은 문서의 정렬을 하는 것에 초점을 두고 있다\r\nTF-IDF와 BM25와 같은 알고리즘의 고도화로 불필요한 doc는 제거가 잘되고 있으니, 무엇을 먼저 보여줄것인가로 관점이 이동했다고 보면 된다\r\n\r\n```\r\n<br/>\r\n\r\n![LTR Structure](/resources/images/MLR-search-engine-example.png)\r\n<span class=\"img_caption\">***(LTR Structure)***</span>\r\n\r\n---\r\n\r\n### LTR: Steps to take\r\n```textbox\r\n1. Create Judgement List\r\n2. Define features for the model\r\n3. Log features during usage\r\n4. Training and testing the model\r\n5. Deploying and using the model\r\n6. Feedback loop\r\n```\r\n\r\n<br/>\r\n\r\n\r\n- **point wise (Regression)** : score를 머신 러닝으로 생성\r\n![point_wise](/resources/images/2019/point_wise.png)  \r\n\r\n<br/>\r\n\r\n- **pair wise (RankNet, LambdaMART)** : 2개씩 비교하며 order를 분류\r\n![pair_wise](/resources/images/2019/pair_wise.png)  \r\n\r\n<br/>\r\n\r\n- **list wise (List Net)** : 전체리스트를 한번에 분류 \r\n![list_wise](/resources/images/2019/list_wise.png)  \r\n\r\n<br/>\r\n\r\n\r\n---\r\n\r\n### Judgement List (판단 리스트)\r\n\r\n```textbox\r\ngrade,keywords,movie\r\n4,Rambo,First Blood     # Exactly Relevant\r\n4,Rambo,Rambo\r\n3,Rambo,Rambo III       # Fairly Relevant\r\n3,Rambo,Rambo First Blood Part II\r\n2,Rambo,Rocky           # Tangentially Relevant\r\n2,Rambo,Cobra\r\n0,Rambo,Bambi           # Not even close...\r\n0,Rambo,First Daughter\r\n```\r\n\r\n```textbox\r\ngrade,keywords,docId\r\n4,rambo,7555\r\n3,rambo,1370\r\n3,rambo,1369\r\n4,rocky,4241\r\n```\r\n\r\n```textbox\r\n# grade (0-4)queryiddocIdtitle\r\n#\r\n# Add your keyword strings below, the feature script will\r\n# Use them to populate your query templates\r\n#\r\n# qid:1: rambo\r\n# qid:2: rocky\r\n# qid:3: bullwinkle\r\n#\r\n# https://sourceforge.net/p/lemur/wiki/RankLib%20File%20Format/\r\n#\r\n#\r\n4qid:1 #7555Rambo\r\n3qid:1 #1370Rambo III\r\n3qid:1 #1369Rambo: First Blood Part II\r\n3qid:1 #1368First Blood\r\n0qid:1 #136278Blood\r\n0qid:1 #102947First Daughter\r\n0qid:1 #13969First Daughter\r\n0qid:1 #61645First Love\r\n0qid:1 #14423First Sunday\r\n0qid:1 #54156First Desires\r\n4qid:2 #1366Rocky\r\n3qid:2 #1246Rocky Balboa\r\n3qid:2 #60375Rocky VI\r\n3qid:2 #1371Rocky III\r\n3qid:2 #1375Rocky V\r\n3qid:2 #1374Rocky IV\r\n0qid:2 #110123Incredible Rocky Mountain Race\r\n0qid:2 #17711The Adventures of Rocky & Bullwinkle\r\n0qid:2 #36685The Rocky Horror Picture Show\r\n4qid:3 #17711The Adventures of Rocky & Bullwinkle\r\n0qid:3 #1246Rocky Balboa\r\n0qid:3 #60375Rocky VI\r\n0qid:3 #1371Rocky III\r\n0qid:3 #1375Rocky V\r\n0qid:3 #1374Rocky IV\r\n```\r\n\r\n---\r\n\r\n### model 생성\r\n\r\n>**1. 모델의 features 정의**\r\n>>검색 결과 및 대상의 따라 다르게 적용 할 수 있습니다  \r\n검색 대상이 공고와 같은 데이터라면 데이터의 단어의 빈도수, 본문 내용, 직종분류등등  만약 검색 대상이 사진이라면 픽셀등으로 일반적인 머신러닝 모델링처럼 구성\r\n\r\n>**2. log 데이터를 활용**\r\n>>로그 데이터를 활용하여 query에 대한 클릭 이벤트 같은 데이터로 모델 구성  \r\n  이후 검색시 같은 쿼리의 대한 클릭에 대하여 모델링 활용\r\n  \r\n<br/>\r\n\r\n\r\n### Search Example\r\n\r\n```json\r\nPOST tmdb/_search\r\n{\r\n  \"query\": {\r\n      \"sltr\": {\r\n              \"params\": {\r\n                  \"keywords\": \"rambo\"\r\n              },\r\n              \"model\": \"my_model\", <- 모델 지정\r\n          }\r\n  }\r\n}\r\n```\r\n*해당 쿼리는 model을 돌리면서 전체의 대한 계속적인 비교작업으로 효율이 떨어짐*\r\n  \r\n<br/>\r\n\r\n\r\n### Rescore Top N\r\n\r\n```json\r\nPOST tmdb/_search\r\n{\r\n  \"query\": {\r\n      \"match\": {\r\n          \"_all\": \"rambo\"\r\n      }\r\n  },        \r\n  \"rescore\": {   # 결과값 도출 이후 상위 1000개의 대해서만 재정렬 진행\r\n      \"window_size\": 1000,\r\n      \"query\": {\r\n          \"rescore_query\": {\r\n              \"sltr\": {\r\n                  \"params\": {\r\n                      \"keywords\": \"rambo\"\r\n                  },\r\n                  \"model\": \"my_model\",\r\n              }\r\n          }\r\n      }\r\n  }\r\n}\r\n```\r\n  \r\n<br/>\r\n\r\n\r\n### Training results\r\n![LTR_traning_result](/resources/images/2019/LTR_traning_result.png)\r\n\r\n---\r\n\r\n### 관련 참조\r\nhttps://github.com/o19s/elasticsearch-learning-to-rank  \r\nhttps://elasticsearch-learning-to-rank.readthedocs.io/en/latest/logging-features.html  \r\nhttps://www.youtube.com/watch?v=TG7aNLgzIcM  \r\nhttp://perpetual.tistory.com/67  \r\nhttp://4four.us/article/2009/10/what-is-learning-to-rank  \r\nhttps://inyl.github.io/search_engine/2017/02/18/solr_learning_to_rank.html  ","fields":{"slug":"/learning_to_rank/"},"frontmatter":{"title":"LTR(Learning To Rank)","published":true}}},{"node":{"rawMarkdownBody":"\r\n# RestTemplate Elastic 통신\r\n***ElasticSearch에서 spring에 있는 RestTemplate를 사용하기 위해서는 RestTemplate의 Post전달***\r\n\r\n```java\r\nclass exRest{\r\n \r\n    RestTemplate restTemplate;\r\n    HttpHeaders headers;\r\n \r\n    public init(){\r\n          restTemplate = new RestTemplate();\r\n          restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());\r\n          Charset utf8 = Charset.forName(\"UTF-8\");\r\n          MediaType mediaType = new MediaType(\"application\", \"json\", utf8); //mediaType을 UTF8로 해줘야만 Post로 전달되는 한글이 인식됨\r\n          headers = new HttpHeaders();\r\n \r\n          HttpEntity<String> httpEntity;\r\n          ResponseEntity<String> responseEntity;\r\n \r\n          httpEntity = new HttpEntity<String>(esQuery, headers);           //esQuery는 Post로 전달할 json 쿼리\r\n          responseEntity = restTemplate.exchange(url, HttpMethod.POST, httpEntity, String.class);     //String형식으로 리턴\r\n    }\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n처음엔 `mediaType`을\r\n\r\n```java\r\nheaders.setContentType(MediaType.APPLICATION_JSON);\r\n``` \r\n로 선언했었는데 이상 없이 보였지만 한글이 들어간 쿼리는 그냥 아무 값이나 전부 가져오는 현상을 보였다  \r\n\r\n\r\n---\r\n\r\n### Configuration로 정의\r\n```java\r\n\r\n@EnableRetry\r\n@Configuration\r\npublic class RestfulConfig {\r\n\r\n    @Bean\r\n    RestTemplate restTemplate(){\r\n        RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory());\r\n        restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());\r\n        return restTemplate;\r\n\r\n    }\r\n\r\n    HttpComponentsClientHttpRequestFactory clientHttpRequestFactory(){\r\n        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();\r\n        factory.setConnectTimeout(15*60*1000);  //15분\r\n        factory.setReadTimeout(15*60*1000);     //15분\r\n        return factory;\r\n    }\r\n\r\n    @Bean\r\n    HttpHeaders httpHeaders(){\r\n\r\n        Charset utf8 = Charset.forName(\"UTF-8\");\r\n        MediaType mediaType = new MediaType(\"application\", \"json\", utf8);   //mediaType을 UTF8로 해줘야만 한글이 인식됨\r\n        HttpHeaders headers = new HttpHeaders();\r\n        headers.setContentType(mediaType);\r\n\r\n        return headers;\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n***지금은 RestTemplate말고 elastic-rest-client를 사용하고 있다 (2019-09-04 작성)***\r\n***RestTemplate 말고 WebClient에 대해 공부하세요! (2019-09-05 작성)***\r\n\r\n\r\n","fields":{"slug":"/elastic_spring_resttemplate/"},"frontmatter":{"title":"RestTemplate Elastic 통신","published":true}}},{"node":{"rawMarkdownBody":"\r\n# Elastic Timezone Issues\r\n>*elastic을 쓰면서 경험한 timezone 문제에 관한 글입니다*  \r\n\r\n###Logstash\r\n1. Logstash의 timezone은 색인할때의 정보가 아닌 filter 자체의 timezone으로 데이터로써 @timestamp의 ***Asia/Seoul***로 설정할시에 기존 시간에서 ***-9시간***을 한 시간을 가져 오게 된다  \r\n2. Logstash의 시간을 설정할 포맷을 정의 할때 timezone 키워드로 Asia/Seoul과 같이 지정해서 시간을 -9시간 할 수 있다\r\n```ruby\r\n   filter{ \r\n                ... \r\n                date{ \r\n                  match => [\"insert_ts\",\"YYYYMMddHHmmss\"] \r\n                  timezone => \"Asia/Seoul\" <- 이부분\r\n                } \r\n                ... \r\n          }\r\n```          \r\n\r\n<br/>\r\n\r\n3. Logstash의 timezone포맷에 +-로 시간을 변경 할 수 있다\r\n```ruby\r\nfilter{      \r\n      date{ \r\n          match => [\"insert_ts\",\"YYYYMMddHHmmss -0900\"] <- 이부분\r\n          timezone => \"Asia/Seoul\" \r\n          } \r\n}\r\n```\r\n\r\n<br/>\r\n\r\n4. ruby코드를 활용해서 시간 조정도 가능하다\r\n```ruby\r\nruby{ \r\n    code => \"event.set('@timestamp', LogStash::Timestamp.new(event.get('@timestamp')+(9*60*60)))\" \r\n}\r\n```\r\n\r\n이 코드의 핵심은 **LogStash::Timestamp**인데..  \r\n`ruby의 time객체`와 `LogStash의 time객체`가 다르다는 것이다<span class=\"sub_header\">(이것 때문에 겁나 해맸다)</span>  \r\n\r\n---\r\n\r\n###Kibana\r\n\r\n 1. 기본적으로 kibana의 Time 기분은 Browser를 따라 간다 <- 이거때문에 KST 기준일때 그래프가 정상적으로 보여서 혼동이 있었다\r\n 2. kibana의 time 기준은 Management > Advanced Settings > dateFormat:tz로 변경할 수 있다\r\n \r\n ---\r\n \r\n ###ElasticSearch\r\n \r\n  1. ElasticSearch의 기존 timezone은 UTC 기준이다 색인도 UTC 기준으로 하길 권고 하고 바꾸지 않기를 권고하고 있다  \r\n>-> 바꾸면 무한 timezone 관리로 계속해서 더 힘들어 질것\r\n  ","fields":{"slug":"/elastic_timezone/"},"frontmatter":{"title":"[Elastic] ElasticSearch Timezone 문제","published":true}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}