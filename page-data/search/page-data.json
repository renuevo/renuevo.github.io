{"componentChunkName":"component---src-pages-search-js","path":"/search/","webpackCompilationHash":"0e029bac122412373e55","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n##사건의 발단\r\n\r\n얼마전 Reactive Programing을 공부하면서 [백기선님의 유튜브](https://www.youtube.com/channel/UCwjaZf1WggZdbczi36bWlBA)를 보다 문득 의문이 생기는 부분이 있었습니다\r\n\r\n```textbox\r\nBy being built around the core pillars of being fully asynchronous and non-blocking,  \r\nReactive Programming is an alternative to the more limited ways of doing asynchronous code in the JDK: namely Callback based APIs and Future.\r\n```\r\n***\"asynchronous하면 당연히 non-blocking 되는 게 아닌가?\"*** &nbsp;지금까지 저는 비동기면 당연히 논블록킹하다고 생각하고 있었습니다   \r\n그래서 알아보게 되었습니다  \r\n\r\n---\r\n\r\n## 동기(Synchronous)와 비동기(Asynchronous)  \r\n***호출된 메서드를 호출하는 쪽에서 관심을 가지고 있는지 봅니다***\r\n\r\n> **1. 동기(Synchronous)**\r\n>> 호출되는 기능의 완료를 호출한 쪽에서 확인하고 처리한다  \r\n>> 단순히 기능의 완료를 호출하는 쪽에서 관심을 보이면 동기로 보면 됩니다  \r\n>> `일반적인 함수 호출`이 여기에 해당됩니다  \r\n\r\n> **2. 비동기(Asynchronous)**\r\n>> 호출되는 기능의 완료를 호출 한 쪽에서 알아서 처리하는 것  \r\n>> 호출하는 쪽에서 비동기로 호출한다는건 해당 기능의 완료가 어떻게 되든 신경쓰지 않는다는 겁니다  \r\n>> 호출된쪽에서는 `callback`을 통해 완료를 전달하게 됩니다  \r\n\r\n\r\n---\r\n\r\n## 블로킹(Blocking)과 논블로킹(NonBlocking)  \r\n***메인 프로세스 플로우의 제어권에 초점을 맞추고 있습니다***\r\n\r\n> **1. 블로킹(Blocking)**\r\n>> 메인 플로우의 제어권이 호출된 쪽으로 넘어가서 해당 제어권을 다시 돌아오기를 기다립니다    \r\n>> 기다리는 동안 메인 플로우는 제어권을 상실하여 아무것도 하지 않습니다  \r\n\r\n> **2. 논블로킹(NonBlocking)**\r\n>> 메인 플로우가 제어권을 바로 반환 받습니다  \r\n>> 메인 플로우는 제어권을 가지고 있으므로 얼마든지 본인의 플로우대로 작업을 실행합니다  \r\n\r\n\r\n---\r\n\r\n## 같이 생각하기  \r\n\r\n***이제 동기와 비동기 & 블로킹과 논블로킹을 같이 생각해 보겠습니다***  \r\n\r\n\r\n![developer_works_metrix](/resources/images/2019/developer_works_metrix.png)\r\n\r\n<span class=\"img_caption\"> 출처 : [Homo Efficio님 블로그](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/) </span>\r\n\r\n<br/>\r\n\r\n그림으로 보면 다음과 같습니다  \r\n2 x 2로 해당 개념들을 믹스해보면 다음과 같습니다\r\n\r\n- Sync-Blocking\r\n- Sync-NonBlocking\r\n- Async-Blocking\r\n- Async-NonBlocking\r\n\r\n그럼 하나하나 차근차근 살펴 보겠습니다\r\n\r\n---\r\n\r\n## 동기 블로킹 (Sync_Blocking)\r\n***메인 프로세스에서 제어권이 넘어가서 작업이 끝나고 제어권을 다시 받는다***\r\n\r\n일반적인 순서대로 호출되는 함수 호출이 Sync_Blocking 입니다\r\n\r\n#### Sample Source\r\n```java\r\n\r\n@SpringBootApplication\r\npublic class SimpleCode{\r\n\r\n    private int sum(int a, int b) {\r\n        return a + b;\r\n    }\r\n\r\n    //Run\r\n    public void syncBlockTest() {\r\n        System.out.println(\"1 + 1 = \" + sum(1, 1));     //제어권이 Sum 메서드로 넘어갑니다\r\n        System.out.println(\"1 + 1 = 귀요미지..\");\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n1 + 1 = 2\r\n1 + 1 = 귀요미지..\r\n\r\n```\r\n\r\n<br/>\r\n\r\n제어권이 sum 메서드로 넘어가며 블로킹 되었고 syncBlockTest는 제어권을 잃어서  \r\n`1 + 1 = 귀요미지..`를 호출하지 않고 기다렸다가 **순차적**으로 실행 되었습니다\r\n\r\n---\r\n\r\n## 동기 논블로킹 (Sync_NonBlocking)\r\n***메인 프로세스에서 제어권이 넘겼다가 바로 받지만 호출된 기능의 완료에 관심을 보입니다***\r\n\r\n**그림을 다시한번 보시겠습니다**\r\n\r\n![sync_nonBlocking](/resources/images/2019/sync_nonBlocking.png)\r\n\r\n<span class=\"img_caption\"> <b> Sync_NonBlocking </b> </span>\r\n\r\n\r\n여기서 부터 애매해서 많이들 어려워하는 부분입니다  \r\n~~하지만 걱정하지 마세요 Sync_NonBlocking은 일반적이지 않습니다~~  \r\n\r\n#### Sample Source\r\n```java\r\n\r\n@Async\r\n@Service\r\npublic class AsyncCodeTest {\r\n    @Async  //Async로 비동기 논블로킹이 자동으로 구현되기 때문에 헷갈리기 쉽습니다\r\n    public Future<Integer> asyncSum(int a, int b) throws Exception{\r\n        Thread.sleep(1000);\r\n        return new AsyncResult<>(a+b);\r\n    }\r\n}\r\n\r\n\r\n@EnableAsync\r\n@SpringBootApplication\r\npublic class SimpleCode {\r\n\r\n    //Run\r\n    public void asyncBlockTest() throws Exception {\r\n        Future<Integer> sumResult = asyncCodeTest.asyncSum(1,1); //제어권을 바로 반환 받습니다(NonBlocking)\r\n        while(!sumResult.isDone()){  //메인 프로세스는 주기적으로 asyncSum의 완료를 확인 합니다(핵심)\r\n            System.out.println(\"1 + 1 = 귀요미지..\");  //asyncSum과 상관없이 메인 프로세스가 자리 일을 합니다           \r\n        }\r\n        System.out.println(\"1 + 1 = \" + sumResult.get());  //asyncSum의 호출을 이미 isDone()으로 알고 있습니다\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n.....\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 2\r\n```\r\n\r\n<br/>\r\n\r\n이부분을 이해하는데 있어서 많이 어려웠던거 같습니다  \r\n@Async면 async지 왜.. sync야 라고 생각하게 되었고 보면 볼수록 더 헷갈리게 되는 개념이었습니다  \r\n\r\n####하지만 판별의 핵심은\r\n> **1. 제어권의 판별**\r\n>> 제어권이 메인 프로세스로 부터 (거의)이관되어 지지 않음 = NonBlocking  \r\n \r\n> **2. 관심의 판별**  \r\n>> 메인 프로세스가 asyncSum의 isDone()을 확인하며 완료를 직접 확인함 = sync \r\n\r\n---\r\n\r\n## 비동기 논블로킹 (Async_NonBlocking)\r\n***메인 프로세스에서 제어권이 넘겼다가 바로 받고 호출된 기능의 완료에 관심을 갖지 않습니다***\r\n\r\n원활한 설명을 위해서 비동기 논블로킹부터 설명하겠습니다\r\n호출된 기능의 완료에 관심을 갖지 않는다는 말은 기능이 알아서 완료여부를 반환해서 Pull 해주는 것도 포함됩니다 <span class=\"sub_header\">(callback)</span>\r\n\r\n#### Sample Source\r\n```java\r\n\r\n@Async\r\n@Service\r\npublic class AsyncCodeTest {\r\n    @Async\r\n    public void asyncSum(int a, int b) throws Exception{\r\n        System.out.println(\"1 + 1 = \"+(a+b));\r\n    }\r\n}\r\n\r\n\r\n@EnableAsync\r\n@SpringBootApplication\r\npublic class SimpleCode {\r\n\r\n    //Run\r\n    public void asyncNonBlockTest() throws Exception {\r\n        asyncCodeTest.asyncSum(1,1);    //asyncNonBlockTest은 제어권을 바로 반환 받습니다\r\n        System.out.println(\"1 + 1 = 귀요미지..\");\r\n        Thread.sleep(1000); //메인 프로세스의 다른 작업들 대신 사용하였습니다 \r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n.....\r\n1 + 1 = 귀요미지..\r\n1 + 1 = 2\r\n```\r\n\r\n<br/>\r\n\r\n메인 프로세스는 asyncSum 호출했지만 바로 제어권을 받아서 `1 + 1 = 귀요미지...`를 출력했습니다  \r\n그리고 여기서는 Thread.sleep(1000)을 사용하였지만 메인 프로세스의 작업들이라고 생각해 주시기 바랍니다  \r\n\r\n```textbox\r\nThread.sleep(1000)을 한 이유는 메인프로세스는 asyncSum을 호출 했지만 완료에  \r\n관심을 갖지 않기 때문에 메인 프로세스가 asyncSum() 완료와 상관없이 먼저 종료 될 수 있습니다\r\n\r\n```\r\n<br/>\r\n\r\n#### 한마디더\r\n다른 건 이해하지 못하더라도 async_nonBlocking은 꼭 알아두셔야 합니다  \r\n위에서 언급했지만 async_nonBlocking은 가장 효율적인이며 이상적인 구조입니다  \r\n***Reactive Programing is built around the core pillars of being fully asynchronous and non-blocking***\r\n\r\n---\r\n\r\n## 비동기 블로킹 (Async_Blocking)\r\n***메인 프로세스에서 제어권이 넘어갔지만 호출된 기능의 완료에 관심을 갖지 않습니다***\r\n\r\n**그림을 다시한번 보시겠습니다**\r\n\r\n![async_blocking](/resources/images/2019/async_blocking.png)\r\n\r\n<span class=\"img_caption\"> <b> Async_Blocking </b> </span>\r\n\r\n저에게는 가장 어려운 개념이었습니다  \r\n제어권이 상대에게 있는데 완료에 관심을 갖지 않는다는게 생각되지 않았기 때문입니다  \r\n그래서 결론 내리길 핵심은 콜백을 받는 입장으로 대기한다라고 생각합니다\r\n\r\n\r\n#### Sample Source\r\n```java\r\n\r\n@Async\r\n@Service\r\npublic class AsyncCodeTest {\r\n    @Async\r\n    public Future<Integer> asyncSum(int a, int b) throws Exception{\r\n        Thread.sleep(1000);\r\n        return new AsyncResult<>(a+b);\r\n    }\r\n}\r\n\r\n\r\n@EnableAsync\r\n@SpringBootApplication\r\npublic class SimpleCode {\r\n\r\n    //Run\r\n    public void asyncBlockTest() throws Exception {\r\n        Future<Integer> sumResult = asyncCodeTest.asyncSum(1, 1); //asyncBlockTest은 제어권을 바로 반환 받습니다 -> 여기서는 nonBlocking으로 해석이 가능합니다\r\n        System.out.println(\"1 + 1 = \" + sumResult.get());   //isDone()의 상태를 모르고 get()하여 대기(blocking)합니다 -> async\r\n        System.out.println(\"1 + 1 = 귀요미지..\");\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n</br>\r\n\r\n#### 실행결과\r\n```\r\n1 + 1 = 2\r\n1 + 1 = 귀요미지..\r\n```\r\n\r\n<br/>\r\n\r\n아까와 같은 Future의 get()을 써서 헷갈리실 수 있지만 엄연히 다른 개념으로 보셔야 합니다  \r\n아까는 메인 프로세스가 isDone()으로 asyncSum의 상태를 계속 해서 확인한 반면 지금은 단순히 get()을 호출하고 asyncSum에서 값을 return 할때 까지 단순히 대기 하고 있습니다  \r\n다시말해 get()을 호출하면 메인 프로세스는 blocking되며 asyncSum에서 값이 Pull 되기를 기다리게 됩니다  \r\n조금 쉽게 이야기하면 ***Async_NonBlocking에서 Blocking되는 상황이 생기면 Async_Blocking이 됩니다***  \r\n\r\n\r\n대표적인 예가 JDBC입니다  \r\nJDBC는 blocking 방식으로 DB에 접근하게 되는데 비동기 환경에서 JDBC로 DB에 접근하게 되는 순간 이 프로세스는 **async_blocking**이 되는 것입니다 \r\n\r\n####하지만 판별의 핵심은\r\n> **1. 제어권의 판별**\r\n>> 제어권이 메인 프로세스로 부터 Future의 get()을 호출 하므로 이관되어짐 = Blocking  \r\n \r\n> **2. 관심의 판별**  \r\n>> 메인 프로세스는 asyncSum가 완료되어 Callable로 Futrue의 get()에 값을 주길 기다림 = sync \r\n\r\n---\r\n\r\n## 마무리\r\n저는 동기(Synchronous)와 비동기(Asynchronous) & 블로킹(Blocking)과 논블로킹(NonBlocking)을 이해하면서 많은 어려움이 있었습니다  \r\n이해 했다가도 다시 볼수록 더 헷갈리고 이해가 안되는 부분이 많았습니다  \r\n공부를 하면서 이런저런 자료를 뒤지던중 많은 자료들을 볼 수 있었고 관련 내용에 대한 많은 토론도 볼 수 있었습니다  \r\n그리고 포스팅을 하면서 지금 제가 내린 **결론은 정답은 없다** 입니다  \r\n\r\n위의 예시도 부분부분적으로 코드를 나눠보면 다른 개념들로 충분히 해석되어 질 수 있습니다  \r\n그러므로 해당 개념들을 간단히 보시고 Synchronous의 개념과 Blocking의 개념이 다르구나를 생각해 주시고  \r\n궁긍적으로 ***Asynchronous_NonBlocking***으로 프로그래밍 패러다임이 이동한다는 것에 집중하시는게 더 좋을 꺼 같습니다","fields":{"slug":"/blocking_nonBlocking_synchronous_asynchronous/"},"frontmatter":{"title":"동기(Synchronous)와 비동기(Asynchronous) & 블로킹(Blocking)과 논블로킹(NonBlocking)","published":true}}},{"node":{"rawMarkdownBody":"\r\n## 옵저버 패턴 <span class=\"sub_header\">(Observer Pattern)</span>\r\n\r\n옵저버 패턴은 Java 내부와 Spring Core, Reative Programming의 기본이 되는 패턴입니다\r\n옵저버 디자인 패턴은 기본적으로 `Subject`와 `Observer`를 가지고 있습니다  \r\n\r\n> **1. Subject**\r\n>> Observer의 Manager 개념으로 Observer를 등록하여 특정 이벤트가 발생했을때 관찰자들이 알 수 있도록 해준다  \r\n\r\n> **2. Observer**\r\n>> 실제 관찰자로 이벤트의 따른 기능들이 구현되어 있고, Subject에 등록되었다가 호출되어 진다  \r\n\r\n기본적으로 Observer 인터페이스를 생성해 두고 Observer를 구현해서 Subject의 등록해서 사용합니다  \r\n***한마디로, 여러 기능들을 하나의 인터페이스로 통합해서 Subject의 등록해서 호출하는 로직으로 볼 수 있습니다 <span class=\"sub_header\">(1 대 N관계)</span>***  \r\n\r\n<br/>\r\n\r\n![observer_pattern](/resources/images/2019/Observer.png)\r\n\r\n<span class=\"img_caption\">출처 : [위키백과 옵서버 패턴](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)</a></span>\r\n\r\n\r\n---\r\n\r\n***이해를 돕기위해 Observer 부터 구현해 보겠습니다***\r\n\r\n### Observer Sample\r\n```java\r\n\r\n    public interface Observer<T> {       //옵저버 인터페이스\r\n        void printEvent(T event);\r\n    }\r\n\r\n    public class ObserverEventA implements Observer<String> { \r\n        @Override\r\n        public void printEvent(String event) {\r\n            System.out.println(\"Event : \" + event);  //옵저버 기능\r\n        }\r\n    }\r\n    \r\n```\r\n\r\n<br/>\r\n\r\n### Subject Sample\r\n```java\r\n\r\n    public interface Subject<T> {\r\n        void registerObserver(Observer<T> observer); //옵저버 등록\r\n\r\n        void removeObserver(Observer<T> observer);   //옵저버 삭제\r\n\r\n        void executeObserver(T event);               //옵저버 실행\r\n    }\r\n\r\n\r\n    public class SampleSubject implements Subject<String> {\r\n\r\n        private final Set<Observer<String>> observerSet = new CopyOnWriteArraySet<>();    //Thread Safe Set\r\n\r\n        public void registerObserver(Observer<String> observer) {\r\n            this.observerSet.add(observer);\r\n        }\r\n\r\n        public void removeObserver(Observer<String> observer) {\r\n            this.observerSet.remove(observer);\r\n        }\r\n\r\n        public void executeObserver(String event) {\r\n            this.observerSet.forEach(o -> o.printEvent(event));\r\n        }\r\n    }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n### Observer Run\r\n```java\r\n\r\n    @Test\r\n    public void observerTest(){\r\n\r\n        Subject<String> subject = new SampleSubject();      //observer manager 생성\r\n        \r\n        subject.registerObserver(new ObserverEventA());     //observer 등록\r\n \r\n        subject.registerObserver(event -> {                 //lambda식 등록도 가능합니다\r\n            System.out.println(\"Event : \" + event);\r\n        });         \r\n        \r\n        subject.registerObserver(System.out::println);      //lambda 단순 println\r\n\r\n        subject.executeObserver(\"Observer Run\");            //실행\r\n    }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n> **실행 결과**\r\n```\r\n\r\nEvent : Observer Run\r\nEvent : Observer Run\r\nObserver Run\r\n\r\n```\r\n\r\n---\r\n## 마무리  \r\nJava에서도 JDK1.0에서 Observer와 Observable이 릴리즈되어 사용할 수 있습니다  \r\n하지만 자바 제네릭이 없던 시절이라.. Object타입을 사용해서 안전성이 보장되지 않습니다\r\n그래서 인지 **JDK9 버젼** 부터는 **Deprecated** 되었습니다\r\n\r\n<br/>\r\n\r\n더 나아가 Observer 구현해서 사용 하시기전 다음과 같은 사항을 권고하고 있습니다  \r\n\r\n>**1. 이벤트 모델**\r\n>> Java.beans 패키지 사용으로 구성  \r\n\r\n>**2. 쓰레드간 메시징**\r\n>>java.util.concurrent 패키지에서 동시 데이터 조작 구조를 사용  \r\n\r\n>**3. Reactive Programing**\r\n>> Flow API를 참조하여 구현\r\n\r\n자세한 관련 내용은 [Java's Observer and Observable Are Deprecated in JDK 9](https://dzone.com/articles/javas-observer-and-observable-are-deprecated-in-jd)를 참고 하세요","fields":{"slug":"/observer_pattern/"},"frontmatter":{"title":"Observer Pattern","published":true}}},{"node":{"rawMarkdownBody":"\r\n#Spring AOP\r\n\r\n## AOP <span class=\"sub_header\">(Aspect-Oriented Programming)</span>\r\n> AOP는 ***관점 지향 프로그래밍***으로 **핵심 비즈니스 기능과 공통기능을 분리**하여 공통기능의 중복을 없애고 객체들간의 관계 복잡도를 줄이는데 사용된다  \r\n> **위빙(Weaving)**을 통해 핵심기능에서 벗어난 공통기능을 정의하고 사용할 수 있다록 한다  \r\n\r\n이렇게 해서 얻을 수 있는 이점을 크게 두가지이다  \r\n```textbox\r\n1. 요청으로 부터 핵심기능으로 접근하는 방법을 제어하기 위해\r\n2. 핵심기능에 대해서 추가적인 기능을 주여해주기 위해\r\n```\r\n\r\n---\r\n## Spring AOP\r\n>Spring에서는 **Proxy**를 이용하여 AOP서비스를 제공한다  \r\n\r\n**1. JDK 동적 프록시**\r\n>>java 리플렉션을 이용하여 개체를 만드는 프록시\r\n\r\n**2. CGLIB 프록시**\r\n>> 바이트 코드를 조작하여 만드는 프록시\r\n\r\n_예전에는 AOP를 위해 interface를 구현해야 했지만, Spring3.2부터 CGLIB가 Spring core에 포함되면서 필요없어 졌다_\r\n\r\n![spring_aop_proxy](/resources/images/2019/spring_aop_proxy.png)  \r\nAOP Object는 마치 자신인 핵심 Core Object처럼 꾸며서 흐름을 제어한다 \r\n\r\n---\r\n###Spring AOP를 사용하기 위한 주요 요건\r\n- **Aspect <span class=\"sub_header\">(@Aspect)</span>**\r\n>>공통 관심사를 모듈화 한 자바 클래스\r\n- **Advice <span class=\"sub_header\">(@Advice)</span>**\r\n>>무엇(What)이 실행될 것인지의 공통기능담은 구현체를 의미\r\n- **Pointcut <span class=\"sub_header\">(@Pointcut)</span>**\r\n>>어디에서(Where) Advice를 실행할 것인지를 정의\r\n\r\n<br/>\r\n\r\n###Advice  \r\n>>1. **Before** : 메서드 호출 이전  \r\n>>2. **After** : 메서드 호출 이후  \r\n>>3. **AfterReturning** : 메서드가 예외없이 실행된 이후  \r\n>>4. **AfterThrowing** : 메서드에 예외가 발생한 이후  \r\n>>5. **Around** : 메서드의 실행 전/후   \r\n\r\n<br/>\r\n\r\n###Pointcut\r\n\r\n<div class=\"table-wrapper\" markdown=\"block\">\r\n\r\nPointcut|Joinpoints\r\n-----|-----\r\nexecution(public * *(..))|public 메소드 실행\r\nexecution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행\r\n|execution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행|\r\n|execution(* com.xyz.service.AccountService.*(..))|AccountService 인터페이스의 모든 메소드 실행|\r\n|execution(* com.xyz.service.*.*(..))|service 패키지의 모든 메소드 실행|\r\n|execution(* com.xyz.service..*.*(..))|service 패키지와 하위 패키지의 모든 메소드 실행|\r\n|within(com.xyz.service.*)|service 패키지 내의 모든 결합점 (클래스 포함)|\r\n|within(com.xyz.service..*)|service 패키지 및 하위 패키지의 모든 결합점 (클래스 포함)|\r\n|this(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 프록시 개체의 모든 결합점|\r\n|target(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 대상 객체의 모든 결합점|\r\n|args(java.io.Serializable)|하나의 파라미터를 갖고 전달된 인자가 Serializable인 모든 결합점|\r\n|@target(org.springframework.transaction.annotation.Transactional)|대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@within(org.springframework.transaction.annotation.Transactional)|대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@annotation(org.springframework.transaction.annotation.Transactional)|실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@args(com.xyz.security.Classified)|단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점|\r\n|bean(accountRepository)|“accountRepository” 빈|\r\n|!bean(accountRepository)|“accountRepository” 빈을 제외한 모든 빈|\r\n|bean(*)|모든 빈|\r\n|bean(account*)|이름이 'account'로 시작되는 모든 빈|\r\n|bean(*Repository)|이름이 “Repository”로 끝나는 모든 빈|\r\n|bean(accounting/*)|이름이 “accounting/“로 시작하는 모든 빈|\r\n|bean(*dataSource)  bean(*DataSource)|이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈|\r\n\r\n</div>\r\n\r\n<span class=\"sub_header\">출처 : [얼청뚱땅 개발자 블로그](https://devjms.tistory.com/70)</span>\r\n\r\n<br/>\r\n\r\n###Simple Source\r\n\r\n<br/>\r\n\r\n***SpringBootApplication***\r\n```java\r\n\r\n@EnableAspectJAutoProxy //AOP 활성화\r\n@SpringBootApplication\r\npublic class SpringBootTestApplication implements CommandLineRunner {\r\n    ...\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SpringBootTestApplication.class, args);\r\n    }\r\n    \r\n    @Override\r\n    public void run(String... args) throws Exception {\r\n        simpleSource.test();\r\n    }\r\n    ...\r\n }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n***AopClass***\r\n```java\r\n@Slf4j\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    @Before(\"execution(* com.service.SimpleSource.test(..))\")\r\n    public void aopBefore(){\r\n        log.info(\"aop before\");\r\n    }\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Recycle***\r\n\r\n```java\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    @Pointcut(\"execution(* *.*(..))\")\r\n    private void logging(){}\r\n    \r\n    @Around(\"logging()\")\r\n    public void aopBefore(){\r\n        log.info(\"aop around\");\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Exclude***\r\n\r\n```java\r\n\r\n@Service\r\npublic class SimpleSource {\r\n    ...\r\n    @NoLogging\r\n    public void logNo(){\r\n       ...\r\n    }\r\n    ...\r\n}\r\n-------------------------------------------------------\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    \r\n    @Pointcut(\"execution(* *.*(..)) && !@target(com.annotation.NoLogging)\")\r\n    private void logging(){}\r\n    \r\n    ...\r\n}\r\n```\r\n*annotation을 구현해서 pointcut에 예외처리 지정하기*\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/spring_aop/"},"frontmatter":{"title":"Spring AOP","published":true}}},{"node":{"rawMarkdownBody":"<figure class=\"float_left\">\r\n\t<img src=\"/images/profile.jpg\" alt=\"profile\">\r\n</figure>\r\n\r\n<div class=\"float_left_content\">\r\n\r\n#Deokhwa Kim <sapn class=\"sub_header\">renuevo0110@gmail.com</span> \r\n*1992.01.10*\r\n\r\n**< Data Service Developer>**  \r\n*사람인HR LAB에 근무중*  \r\n평소에 **Spring**으로 개발하며 요즘은 **Java**대신 주로 **Kotlin**으로 개발하고 있습니다    \r\n최근 관심사는 Reactive Programing과 MSA 입니다\r\n\r\n</div>\r\n\r\n<p class=\"clear_float\"></p>\r\n\r\n---\r\n\r\n![dev_life](/resources/images/2019/profile_dev_life.jpg)","fields":{"slug":"/profile/"},"frontmatter":{"title":"Profile","published":true}}},{"node":{"rawMarkdownBody":"\r\n## LTR <span class=\"sub_header\">(Learning To Rank)</span>\r\n\r\n#### 스코어 정렬에 머신러닝 알고리즘을 사용\r\n```textbox\r\n\r\nTF-IDF와 BM25가 검색결과를 도출하는 하고 상관없는 문서를 빼는것에 초점을 둔 반면 LTR은 문서의 정렬을 하는 것에 초점을 두고 있다\r\nTF-IDF와 BM25와 같은 알고리즘의 고도화로 불필요한 doc는 제거가 잘되고 있으니, 무엇을 먼저 보여줄것인가로 관점이 이동했다고 보면 된다\r\n\r\n```\r\n<br/>\r\n\r\n![LTR Structure](/resources/images/MLR-search-engine-example.png)\r\n<span class=\"img_caption\">***(LTR Structure)***</span>\r\n\r\n---\r\n\r\n### LTR: Steps to take\r\n```textbox\r\n1. Create Judgement List\r\n2. Define features for the model\r\n3. Log features during usage\r\n4. Training and testing the model\r\n5. Deploying and using the model\r\n6. Feedback loop\r\n```\r\n\r\n<br/>\r\n\r\n\r\n- **point wise (Regression)** : score를 머신 러닝으로 생성\r\n![point_wise](/resources/images/2019/point_wise.png)  \r\n\r\n<br/>\r\n\r\n- **pair wise (RankNet, LambdaMART)** : 2개씩 비교하며 order를 분류\r\n![pair_wise](/resources/images/2019/pair_wise.png)  \r\n\r\n<br/>\r\n\r\n- **list wise (List Net)** : 전체리스트를 한번에 분류 \r\n![list_wise](/resources/images/2019/list_wise.png)  \r\n\r\n<br/>\r\n\r\n\r\n---\r\n\r\n### Judgement List (판단 리스트)\r\n\r\n```textbox\r\ngrade,keywords,movie\r\n4,Rambo,First Blood     # Exactly Relevant\r\n4,Rambo,Rambo\r\n3,Rambo,Rambo III       # Fairly Relevant\r\n3,Rambo,Rambo First Blood Part II\r\n2,Rambo,Rocky           # Tangentially Relevant\r\n2,Rambo,Cobra\r\n0,Rambo,Bambi           # Not even close...\r\n0,Rambo,First Daughter\r\n```\r\n\r\n```textbox\r\ngrade,keywords,docId\r\n4,rambo,7555\r\n3,rambo,1370\r\n3,rambo,1369\r\n4,rocky,4241\r\n```\r\n\r\n```textbox\r\n# grade (0-4)queryiddocIdtitle\r\n#\r\n# Add your keyword strings below, the feature script will\r\n# Use them to populate your query templates\r\n#\r\n# qid:1: rambo\r\n# qid:2: rocky\r\n# qid:3: bullwinkle\r\n#\r\n# https://sourceforge.net/p/lemur/wiki/RankLib%20File%20Format/\r\n#\r\n#\r\n4qid:1 #7555Rambo\r\n3qid:1 #1370Rambo III\r\n3qid:1 #1369Rambo: First Blood Part II\r\n3qid:1 #1368First Blood\r\n0qid:1 #136278Blood\r\n0qid:1 #102947First Daughter\r\n0qid:1 #13969First Daughter\r\n0qid:1 #61645First Love\r\n0qid:1 #14423First Sunday\r\n0qid:1 #54156First Desires\r\n4qid:2 #1366Rocky\r\n3qid:2 #1246Rocky Balboa\r\n3qid:2 #60375Rocky VI\r\n3qid:2 #1371Rocky III\r\n3qid:2 #1375Rocky V\r\n3qid:2 #1374Rocky IV\r\n0qid:2 #110123Incredible Rocky Mountain Race\r\n0qid:2 #17711The Adventures of Rocky & Bullwinkle\r\n0qid:2 #36685The Rocky Horror Picture Show\r\n4qid:3 #17711The Adventures of Rocky & Bullwinkle\r\n0qid:3 #1246Rocky Balboa\r\n0qid:3 #60375Rocky VI\r\n0qid:3 #1371Rocky III\r\n0qid:3 #1375Rocky V\r\n0qid:3 #1374Rocky IV\r\n```\r\n\r\n---\r\n\r\n### model 생성\r\n\r\n>**1. 모델의 features 정의**\r\n>>검색 결과 및 대상의 따라 다르게 적용 할 수 있습니다  \r\n검색 대상이 공고와 같은 데이터라면 데이터의 단어의 빈도수, 본문 내용, 직종분류등등  만약 검색 대상이 사진이라면 픽셀등으로 일반적인 머신러닝 모델링처럼 구성\r\n\r\n>**2. log 데이터를 활용**\r\n>>로그 데이터를 활용하여 query에 대한 클릭 이벤트 같은 데이터로 모델 구성  \r\n  이후 검색시 같은 쿼리의 대한 클릭에 대하여 모델링 활용\r\n  \r\n<br/>\r\n\r\n\r\n### Search Example\r\n\r\n```json\r\nPOST tmdb/_search\r\n{\r\n  \"query\": {\r\n      \"sltr\": {\r\n              \"params\": {\r\n                  \"keywords\": \"rambo\"\r\n              },\r\n              \"model\": \"my_model\", <- 모델 지정\r\n          }\r\n  }\r\n}\r\n```\r\n*해당 쿼리는 model을 돌리면서 전체의 대한 계속적인 비교작업으로 효율이 떨어짐*\r\n  \r\n<br/>\r\n\r\n\r\n### Rescore Top N\r\n\r\n```json\r\nPOST tmdb/_search\r\n{\r\n  \"query\": {\r\n      \"match\": {\r\n          \"_all\": \"rambo\"\r\n      }\r\n  },        \r\n  \"rescore\": {   # 결과값 도출 이후 상위 1000개의 대해서만 재정렬 진행\r\n      \"window_size\": 1000,\r\n      \"query\": {\r\n          \"rescore_query\": {\r\n              \"sltr\": {\r\n                  \"params\": {\r\n                      \"keywords\": \"rambo\"\r\n                  },\r\n                  \"model\": \"my_model\",\r\n              }\r\n          }\r\n      }\r\n  }\r\n}\r\n```\r\n  \r\n<br/>\r\n\r\n\r\n### Training results\r\n![LTR_traning_result](/resources/images/2019/LTR_traning_result.png)\r\n\r\n---\r\n\r\n### 관련 참조\r\nhttps://github.com/o19s/elasticsearch-learning-to-rank  \r\nhttps://elasticsearch-learning-to-rank.readthedocs.io/en/latest/logging-features.html  \r\nhttps://www.youtube.com/watch?v=TG7aNLgzIcM  \r\nhttp://perpetual.tistory.com/67  \r\nhttp://4four.us/article/2009/10/what-is-learning-to-rank  \r\nhttps://inyl.github.io/search_engine/2017/02/18/solr_learning_to_rank.html  ","fields":{"slug":"/learning_to_rank/"},"frontmatter":{"title":"LTR(Learning To Rank)","published":true}}},{"node":{"rawMarkdownBody":"\r\n## RestTemplate Elastic 통신\r\n***ElasticSearch에서 spring에 있는 RestTemplate를 사용하기 위해서는 RestTemplate의 Post전달***\r\n\r\n```java\r\nclass exRest{\r\n \r\n    RestTemplate restTemplate;\r\n    HttpHeaders headers;\r\n \r\n    public init(){\r\n          restTemplate = new RestTemplate();\r\n          restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());\r\n          Charset utf8 = Charset.forName(\"UTF-8\");\r\n          MediaType mediaType = new MediaType(\"application\", \"json\", utf8); //mediaType을 UTF8로 해줘야만 Post로 전달되는 한글이 인식됨\r\n          headers = new HttpHeaders();\r\n \r\n          HttpEntity<String> httpEntity;\r\n          ResponseEntity<String> responseEntity;\r\n \r\n          httpEntity = new HttpEntity<String>(esQuery, headers);           //esQuery는 Post로 전달할 json 쿼리\r\n          responseEntity = restTemplate.exchange(url, HttpMethod.POST, httpEntity, String.class);     //String형식으로 리턴\r\n    }\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n처음엔 `mediaType`을\r\n\r\n```java\r\nheaders.setContentType(MediaType.APPLICATION_JSON);\r\n``` \r\n로 선언했었는데 이상 없이 보였지만 한글이 들어간 쿼리는 그냥 아무 값이나 전부 가져오는 현상을 보였다  \r\n\r\n\r\n---\r\n\r\n### Configuration로 정의\r\n```java\r\n\r\n@EnableRetry\r\n@Configuration\r\npublic class RestfulConfig {\r\n\r\n    @Bean\r\n    RestTemplate restTemplate(){\r\n        RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory());\r\n        restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());\r\n        return restTemplate;\r\n\r\n    }\r\n\r\n    HttpComponentsClientHttpRequestFactory clientHttpRequestFactory(){\r\n        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();\r\n        factory.setConnectTimeout(15*60*1000);  //15분\r\n        factory.setReadTimeout(15*60*1000);     //15분\r\n        return factory;\r\n    }\r\n\r\n    @Bean\r\n    HttpHeaders httpHeaders(){\r\n\r\n        Charset utf8 = Charset.forName(\"UTF-8\");\r\n        MediaType mediaType = new MediaType(\"application\", \"json\", utf8);   //mediaType을 UTF8로 해줘야만 한글이 인식됨\r\n        HttpHeaders headers = new HttpHeaders();\r\n        headers.setContentType(mediaType);\r\n\r\n        return headers;\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n***지금은 RestTemplate말고 elastic-rest-client를 사용하고 있다 (2019-09-04 작성)***\r\n***RestTemplate 말고 WebClient에 대해 공부하세요! (2019-09-05 작성)***\r\n\r\n\r\n","fields":{"slug":"/elastic_spring_resttemplate/"},"frontmatter":{"title":"RestTemplate Elastic 통신","published":true}}},{"node":{"rawMarkdownBody":"\r\n## Elastic Timezone Issues\r\n>*elastic을 쓰면서 경험한 timezone 문제에 관한 글입니다*  \r\n\r\n###Logstash\r\n1. Logstash의 timezone은 색인할때의 정보가 아닌 filter 자체의 timezone으로 데이터로써 @timestamp의 ***Asia/Seoul***로 설정할시에 기존 시간에서 ***-9시간***을 한 시간을 가져 오게 된다  \r\n2. Logstash의 시간을 설정할 포맷을 정의 할때 timezone 키워드로 Asia/Seoul과 같이 지정해서 시간을 -9시간 할 수 있다\r\n```ruby\r\n   filter{ \r\n                ... \r\n                date{ \r\n                  match => [\"insert_ts\",\"YYYYMMddHHmmss\"] \r\n                  timezone => \"Asia/Seoul\" <- 이부분\r\n                } \r\n                ... \r\n          }\r\n```          \r\n\r\n<br/>\r\n\r\n3. Logstash의 timezone포맷에 +-로 시간을 변경 할 수 있다\r\n```ruby\r\nfilter{      \r\n      date{ \r\n          match => [\"insert_ts\",\"YYYYMMddHHmmss -0900\"] <- 이부분\r\n          timezone => \"Asia/Seoul\" \r\n          } \r\n}\r\n```\r\n\r\n<br/>\r\n\r\n4. ruby코드를 활용해서 시간 조정도 가능하다\r\n```ruby\r\nruby{ \r\n    code => \"event.set('@timestamp', LogStash::Timestamp.new(event.get('@timestamp')+(9*60*60)))\" \r\n}\r\n```\r\n\r\n이 코드의 핵심은 **LogStash::Timestamp**인데..  \r\n`ruby의 time객체`와 `LogStash의 time객체`가 다르다는 것이다<span class=\"sub_header\">(이것 때문에 겁나 해맸다)</span>  \r\n\r\n---\r\n\r\n###Kibana\r\n\r\n 1. 기본적으로 kibana의 Time 기분은 Browser를 따라 간다 <- 이거때문에 KST 기준일때 그래프가 정상적으로 보여서 혼동이 있었다\r\n 2. kibana의 time 기준은 Management > Advanced Settings > dateFormat:tz로 변경할 수 있다\r\n \r\n ---\r\n \r\n ###ElasticSearch\r\n \r\n  1. ElasticSearch의 기존 timezone은 UTC 기준이다 색인도 UTC 기준으로 하길 권고 하고 바꾸지 않기를 권고하고 있다  \r\n>-> 바꾸면 무한 timezone 관리로 계속해서 더 힘들어 질것\r\n  ","fields":{"slug":"/elastic_timezone/"},"frontmatter":{"title":"ElasticSearch Timezone 문제","published":true}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}