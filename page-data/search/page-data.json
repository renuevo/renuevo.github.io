{"componentChunkName":"component---src-pages-search-js","path":"/search/","webpackCompilationHash":"90e0018b0dc93fbf36cd","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n#Spring AOP\r\n\r\n## AOP <span class=\"sub_header\">(Aspect-Oriented Programming)</span>\r\n> AOP는 ***관점 지향 프로그래밍***으로 **핵심 비즈니스 기능과 공통기능을 분리**하여 공통기능의 중복을 없애고 객체들간의 관계 복잡도를 줄이는데 사용된다  \r\n> **위빙(Weaving)**을 통해 핵심기능에서 벗어난 공통기능을 정의하고 사용할 수 있다록 한다  \r\n\r\n이렇게 해서 얻을 수 있는 이점을 크게 두가지이다  \r\n```\r\n1. 요청으로 부터 핵심기능으로 접근하는 방법을 제어하기 위해\r\n2. 핵심기능에 대해서 추가적인 기능을 주여해주기 위해\r\n```\r\n\r\n---\r\n## Spring AOP\r\n>Spring에서는 **Proxy**를 이용하여 AOP서비스를 제공한다  \r\n\r\n**1. JDK 동적 프록시**\r\n>>java 리플렉션을 이용하여 개체를 만드는 프록시\r\n\r\n**2. CGLIB 프록시**\r\n>> 바이트 코드를 조작하여 만드는 프록시\r\n\r\n_예전에는 AOP를 위해 interface를 구현해야 했지만, Spring3.2부터 CGLIB가 Spring core에 포함되면서 필요없어 졌다_\r\n\r\n![spring_aop_proxy](/resources/images/spring_aop_proxy.png)  \r\nAOP Object는 마치 자신인 핵심 Core Object처럼 꾸며서 흐름을 제어한다 \r\n\r\n---\r\n###Spring AOP를 사용하기 위한 주요 요건\r\n- **Aspect <span class=\"sub_header\">(@Aspect)</span>**\r\n>>공통 관심사를 모듈화 한 자바 클래스\r\n- **Advice <span class=\"sub_header\">(@Advice)</span>**\r\n>>무엇(What)이 실행될 것인지의 공통기능담은 구현체를 의미\r\n- **Pointcut <span class=\"sub_header\">(@Pointcut)</span>**\r\n>>어디에서(Where) Advice를 실행할 것인지를 정의\r\n\r\n<br/>\r\n\r\n###Advice  \r\n>>1. **Before** : 메서드 호출 이전  \r\n>>2. **After** : 메서드 호출 이후  \r\n>>3. **AfterReturning** : 메서드가 예외없이 실행된 이후  \r\n>>4. **AfterThrowing** : 메서드에 예외가 발생한 이후  \r\n>>5. **Around** : 메서드의 실행 전/후   \r\n\r\n<br/>\r\n\r\n###Pointcut\r\n\r\n<div class=\"table-wrapper\" markdown=\"block\">\r\n\r\nPointcut|Joinpoints\r\n-----|-----\r\nexecution(public * *(..))|public 메소드 실행\r\nexecution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행\r\n|execution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행|\r\n|execution(* com.xyz.service.AccountService.*(..))|AccountService 인터페이스의 모든 메소드 실행|\r\n|execution(* com.xyz.service.*.*(..))|service 패키지의 모든 메소드 실행|\r\n|execution(* com.xyz.service..*.*(..))|service 패키지와 하위 패키지의 모든 메소드 실행|\r\n|within(com.xyz.service.*)|service 패키지 내의 모든 결합점 (클래스 포함)|\r\n|within(com.xyz.service..*)|service 패키지 및 하위 패키지의 모든 결합점 (클래스 포함)|\r\n|this(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 프록시 개체의 모든 결합점|\r\n|target(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 대상 객체의 모든 결합점|\r\n|args(java.io.Serializable)|하나의 파라미터를 갖고 전달된 인자가 Serializable인 모든 결합점|\r\n|@target(org.springframework.transaction.annotation.Transactional)|대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@within(org.springframework.transaction.annotation.Transactional)|대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@annotation(org.springframework.transaction.annotation.Transactional)|실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@args(com.xyz.security.Classified)|단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점|\r\n|bean(accountRepository)|“accountRepository” 빈|\r\n|!bean(accountRepository)|“accountRepository” 빈을 제외한 모든 빈|\r\n|bean(*)|모든 빈|\r\n|bean(account*)|이름이 'account'로 시작되는 모든 빈|\r\n|bean(*Repository)|이름이 “Repository”로 끝나는 모든 빈|\r\n|bean(accounting/*)|이름이 “accounting/“로 시작하는 모든 빈|\r\n|bean(*dataSource)  bean(*DataSource)|이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈|\r\n\r\n</div>\r\n\r\n<span class=\"sub_header\">출처 : [얼청뚱땅 개발자 블로그](https://devjms.tistory.com/70)</span>\r\n\r\n<br/>\r\n\r\n###Simple Source\r\n\r\n<br/>\r\n\r\n***SpringBootApplication***\r\n```java\r\n\r\n@EnableAspectJAutoProxy //AOP 활성화\r\n@SpringBootApplication\r\npublic class SpringBootTestApplication implements CommandLineRunner {\r\n    ...\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SpringBootTestApplication.class, args);\r\n    }\r\n    \r\n    @Override\r\n    public void run(String... args) throws Exception {\r\n        simpleSource.test();\r\n    }\r\n    ...\r\n }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n***AopClass***\r\n```java\r\n@Slf4j\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    @Before(\"execution(* com.service.SimpleSource.test(..))\")\r\n    public void aopBefore(){\r\n        log.info(\"aop before\");\r\n    }\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Recycle***\r\n\r\n```java\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    @Pointcut(\"execution(* *.*(..))\")\r\n    private void logging(){}\r\n    \r\n    @Around(\"logging()\")\r\n    public void aopBefore(){\r\n        log.info(\"aop around\");\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Exclude***\r\n\r\n```java\r\n\r\n@Service\r\npublic class SimpleSource {\r\n    ...\r\n    @NoLogging\r\n    public void logNo(){\r\n       ...\r\n    }\r\n    ...\r\n}\r\n-------------------------------------------------------\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    \r\n    @Pointcut(\"execution(* *.*(..)) && !@target(com.annotation.NoLogging)\")\r\n    private void logging(){}\r\n    \r\n    ...\r\n}\r\n```\r\n*annotation을 구현해서 pointcut에 예외처리 지정하기*\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/spring_aop_20190904/"},"frontmatter":{"title":"Spring AOP","published":true}}},{"node":{"rawMarkdownBody":"<figure class=\"float_left\" style=\"width: 400px\">\r\n\t<img src=\"/images/profile.jpg\" alt=\"profile\">\r\n</figure>\r\n\r\n<br/>\r\n\r\n#Deokhwa Kim \r\n*1992.01.10*\r\n\r\n**< Data Service Developer>**  \r\n*사람인HR LAB에 근무중*  \r\n**Spring**을 주로 사용하여 개발하며 요즘은 **Java**대신 **Kotlin**으로 개발하고 있습니다  \r\n\r\n---\r\n\r\n![dev_life](/resources/images/profile_dev_life.jpg)","fields":{"slug":"/profile/"},"frontmatter":{"title":"Profile","published":true}}},{"node":{"rawMarkdownBody":"\r\n## LTR <span class=\"sub_header\">(Learning To Rank)</span>\r\n\r\n#### 스코어 정렬에 머신러닝 알고리즘을 사용\r\n```\r\n\r\nTF-IDF와 BM25가 검색결과를 도출하는 하고 상관없는 문서를 빼는것에 초점을 둔 반면 LTR은 문서의 정렬을 하는 것에 초점을 두고 있다\r\nTF-IDF와 BM25와 같은 알고리즘의 고도화로 불필요한 doc는 제거가 잘되고 있으니, 무엇을 먼저 보여줄것인가로 관점이 이동했다고 보면 된다\r\n\r\n```\r\n<br/>\r\n\r\n![LTR Structure](/resources/images/MLR-search-engine-example.png)\r\n<span class=\"img_caption\">***(LTR Structure)***</span>\r\n\r\n---\r\n\r\n### LTR: Steps to take\r\n```\r\n1. Create Judgement List\r\n2. Define features for the model\r\n3. Log features during usage\r\n4. Training and testing the model\r\n5. Deploying and using the model\r\n6. Feedback loop\r\n```\r\n\r\n<br/>\r\n\r\n\r\n- **point wise (Regression)** : score를 머신 러닝으로 생성\r\n![point_wise](/resources/images/point_wise.png)  \r\n\r\n<br/>\r\n\r\n- **pair wise (RankNet, LambdaMART)** : 2개씩 비교하며 order를 분류\r\n![pair_wise](/resources/images/pair_wise.png)  \r\n\r\n<br/>\r\n\r\n- **list wise (List Net)** : 전체리스트를 한번에 분류 \r\n![list_wise](/resources/images/list_wise.png)  \r\n\r\n<br/>\r\n\r\n\r\n---\r\n\r\n### Judgement List (판단 리스트)\r\n\r\n```\r\ngrade,keywords,movie\r\n4,Rambo,First Blood     # Exactly Relevant\r\n4,Rambo,Rambo\r\n3,Rambo,Rambo III       # Fairly Relevant\r\n3,Rambo,Rambo First Blood Part II\r\n2,Rambo,Rocky           # Tangentially Relevant\r\n2,Rambo,Cobra\r\n0,Rambo,Bambi           # Not even close...\r\n0,Rambo,First Daughter\r\n```\r\n\r\n```\r\ngrade,keywords,docId\r\n4,rambo,7555\r\n3,rambo,1370\r\n3,rambo,1369\r\n4,rocky,4241\r\n```\r\n\r\n```\r\n# grade (0-4)queryiddocIdtitle\r\n#\r\n# Add your keyword strings below, the feature script will\r\n# Use them to populate your query templates\r\n#\r\n# qid:1: rambo\r\n# qid:2: rocky\r\n# qid:3: bullwinkle\r\n#\r\n# https://sourceforge.net/p/lemur/wiki/RankLib%20File%20Format/\r\n#\r\n#\r\n4qid:1 #7555Rambo\r\n3qid:1 #1370Rambo III\r\n3qid:1 #1369Rambo: First Blood Part II\r\n3qid:1 #1368First Blood\r\n0qid:1 #136278Blood\r\n0qid:1 #102947First Daughter\r\n0qid:1 #13969First Daughter\r\n0qid:1 #61645First Love\r\n0qid:1 #14423First Sunday\r\n0qid:1 #54156First Desires\r\n4qid:2 #1366Rocky\r\n3qid:2 #1246Rocky Balboa\r\n3qid:2 #60375Rocky VI\r\n3qid:2 #1371Rocky III\r\n3qid:2 #1375Rocky V\r\n3qid:2 #1374Rocky IV\r\n0qid:2 #110123Incredible Rocky Mountain Race\r\n0qid:2 #17711The Adventures of Rocky & Bullwinkle\r\n0qid:2 #36685The Rocky Horror Picture Show\r\n4qid:3 #17711The Adventures of Rocky & Bullwinkle\r\n0qid:3 #1246Rocky Balboa\r\n0qid:3 #60375Rocky VI\r\n0qid:3 #1371Rocky III\r\n0qid:3 #1375Rocky V\r\n0qid:3 #1374Rocky IV\r\n```\r\n\r\n---\r\n\r\n### model 생성\r\n\r\n>**1. 모델의 features 정의**\r\n>>검색 결과 및 대상의 따라 다르게 적용 할 수 있습니다  \r\n검색 대상이 공고와 같은 데이터라면 데이터의 단어의 빈도수, 본문 내용, 직종분류등등  만약 검색 대상이 사진이라면 픽셀등으로 일반적인 머신러닝 모델링처럼 구성\r\n\r\n>**2. log 데이터를 활용**\r\n>>로그 데이터를 활용하여 query에 대한 클릭 이벤트 같은 데이터로 모델 구성  \r\n  이후 검색시 같은 쿼리의 대한 클릭에 대하여 모델링 활용\r\n  \r\n<br/>\r\n\r\n\r\n### Search Example\r\n\r\n```json\r\nPOST tmdb/_search\r\n{\r\n  \"query\": {\r\n      \"sltr\": {\r\n              \"params\": {\r\n                  \"keywords\": \"rambo\"\r\n              },\r\n              \"model\": \"my_model\", <- 모델 지정\r\n          }\r\n  }\r\n}\r\n```\r\n*해당 쿼리는 model을 돌리면서 전체의 대한 계속적인 비교작업으로 효율이 떨어짐*\r\n  \r\n<br/>\r\n\r\n\r\n### Rescore Top N\r\n\r\n```json\r\nPOST tmdb/_search\r\n{\r\n  \"query\": {\r\n      \"match\": {\r\n          \"_all\": \"rambo\"\r\n      }\r\n  },        \r\n  \"rescore\": {   # 결과값 도출 이후 상위 1000개의 대해서만 재정렬 진행\r\n      \"window_size\": 1000,\r\n      \"query\": {\r\n          \"rescore_query\": {\r\n              \"sltr\": {\r\n                  \"params\": {\r\n                      \"keywords\": \"rambo\"\r\n                  },\r\n                  \"model\": \"my_model\",\r\n              }\r\n          }\r\n      }\r\n  }\r\n}\r\n```\r\n  \r\n<br/>\r\n\r\n\r\n### Training results\r\n![LTR_traning_result](/resources/images/LTR_traning_result.png)\r\n\r\n---\r\n\r\n### 관련 참조\r\nhttps://github.com/o19s/elasticsearch-learning-to-rank  \r\nhttps://elasticsearch-learning-to-rank.readthedocs.io/en/latest/logging-features.html  \r\nhttps://www.youtube.com/watch?v=TG7aNLgzIcM  \r\nhttp://perpetual.tistory.com/67  \r\nhttp://4four.us/article/2009/10/what-is-learning-to-rank  \r\nhttps://inyl.github.io/search_engine/2017/02/18/solr_learning_to_rank.html  ","fields":{"slug":"/learning_to_rank/"},"frontmatter":{"title":"LTR(Learning To Rank)","published":true}}},{"node":{"rawMarkdownBody":"\r\n## RestTemplate Elastic 통신\r\n***ElasticSearch에서 spring에 있는 RestTemplate를 사용하기 위해서는 RestTemplate의 Post전달***\r\n\r\n```java\r\nclass exRest{\r\n \r\n    RestTemplate restTemplate;\r\n    HttpHeaders headers;\r\n \r\n    public init(){\r\n          restTemplate = new RestTemplate();\r\n          restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());\r\n          Charset utf8 = Charset.forName(\"UTF-8\");\r\n          MediaType mediaType = new MediaType(\"application\", \"json\", utf8); //mediaType을 UTF8로 해줘야만 Post로 전달되는 한글이 인식됨\r\n          headers = new HttpHeaders();\r\n \r\n          HttpEntity<String> httpEntity;\r\n          ResponseEntity<String> responseEntity;\r\n \r\n          httpEntity = new HttpEntity<String>(esQuery, headers);           //esQuery는 Post로 전달할 json 쿼리\r\n          responseEntity = restTemplate.exchange(url, HttpMethod.POST, httpEntity, String.class);     //String형식으로 리턴\r\n    }\r\n}\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n처음엔 `mediaType`을\r\n\r\n```java\r\nheaders.setContentType(MediaType.APPLICATION_JSON);\r\n``` \r\n로 선언했었는데 이상 없이 보였지만 한글이 들어간 쿼리는 그냥 아무 값이나 전부 가져오는 현상을 보였다  \r\n\r\n\r\n---\r\n\r\n### Configuration로 정의\r\n```java\r\n\r\n@EnableRetry\r\n@Configuration\r\npublic class RestfulConfig {\r\n\r\n    @Bean\r\n    RestTemplate restTemplate(){\r\n        RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory());\r\n        restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());\r\n        return restTemplate;\r\n\r\n    }\r\n\r\n    HttpComponentsClientHttpRequestFactory clientHttpRequestFactory(){\r\n        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();\r\n        factory.setConnectTimeout(15*60*1000);  //15분\r\n        factory.setReadTimeout(15*60*1000);     //15분\r\n        return factory;\r\n    }\r\n\r\n    @Bean\r\n    HttpHeaders httpHeaders(){\r\n\r\n        Charset utf8 = Charset.forName(\"UTF-8\");\r\n        MediaType mediaType = new MediaType(\"application\", \"json\", utf8);   //mediaType을 UTF8로 해줘야만 한글이 인식됨\r\n        HttpHeaders headers = new HttpHeaders();\r\n        headers.setContentType(mediaType);\r\n\r\n        return headers;\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n***지금은 RestTemplate말고 elastic-rest-client를 사용하고있다 (2019-09-04 작성)***\r\n\r\n\r\n","fields":{"slug":"/elastic_spring_resttemplate/"},"frontmatter":{"title":"RestTemplate Elastic 통신","published":true}}},{"node":{"rawMarkdownBody":"\r\n## Elastic Timezone Issues\r\n>*elastic을 쓰면서 경험한 timezone 문제에 관한 글입니다*  \r\n\r\n###Logstash\r\n1. Logstash의 timezone은 색인할때의 정보가 아닌 filter 자체의 timezone으로 데이터로써 @timestamp의 ***Asia/Seoul***로 설정할시에 기존 시간에서 ***-9시간***을 한 시간을 가져 오게 된다  \r\n2. Logstash의 시간을 설정할 포맷을 정의 할때 timezone 키워드로 Asia/Seoul과 같이 지정해서 시간을 -9시간 할 수 있다\r\n```ruby\r\n   filter{ \r\n                ... \r\n                date{ \r\n                  match => [\"insert_ts\",\"YYYYMMddHHmmss\"] \r\n                  timezone => \"Asia/Seoul\" <- 이부분\r\n                } \r\n                ... \r\n          }\r\n```          \r\n\r\n<br/>\r\n\r\n3. Logstash의 timezone포맷에 +-로 시간을 변경 할 수 있다\r\n```ruby\r\nfilter{      \r\n      date{ \r\n          match => [\"insert_ts\",\"YYYYMMddHHmmss -0900\"] <- 이부분\r\n          timezone => \"Asia/Seoul\" \r\n          } \r\n}\r\n```\r\n\r\n<br/>\r\n\r\n4. ruby코드를 활용해서 시간 조정도 가능하다\r\n```ruby\r\nruby{ \r\n    code => \"event.set('@timestamp', LogStash::Timestamp.new(event.get('@timestamp')+(9*60*60)))\" \r\n}\r\n```\r\n\r\n이 코드의 핵심은 **LogStash::Timestamp**인데..  \r\n`ruby의 time객체`와 `LogStash의 time객체`가 다르다는 것이다<span class=\"sub_header\">(이것 때문에 겁나 해맸다)</span>  \r\n\r\n---\r\n\r\n###Kibana\r\n\r\n 1. 기본적으로 kibana의 Time 기분은 Browser를 따라 간다 <- 이거때문에 KST 기준일때 그래프가 정상적으로 보여서 혼동이 있었다\r\n 2. kibana의 time 기준은 Management > Advanced Settings > dateFormat:tz로 변경할 수 있다\r\n \r\n ---\r\n \r\n ###ElasticSearch\r\n \r\n  1. ElasticSearch의 기존 timezone은 UTC 기준이다 색인도 UTC 기준으로 하길 권고 하고 바꾸지 않기를 권고하고 있다  \r\n>-> 바꾸면 무한 timezone 관리로 계속해서 더 힘들어 질것\r\n  ","fields":{"slug":"/elastic_timezone/"},"frontmatter":{"title":"ElasticSearch Timezone 문제","published":true}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}