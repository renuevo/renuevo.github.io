{"componentChunkName":"component---src-pages-search-js","path":"/search/","webpackCompilationHash":"98502b37ffc121193a75","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n#Srping AOP\r\n\r\n## AOP <span class=\"sub_header\">(Aspect-Oriented Programming)</span>\r\n> AOP는 ***관점 지향 프로그래밍***으로 **핵심 비즈니스 기능과 공통기능을 분리**하여 공통기능의 중복을 없애고 객체들간의 관계 복잡도를 줄이는데 사용된다  \r\n> **위빙(Weaving)**을 통해 핵심기능에서 벗어난 공통기능을 정의하고 사용할 수 있다록 한다  \r\n\r\n이렇게 해서 얻을 수 있는 이점을 크게 두가지이다  \r\n```\r\n1. 요청으로 부터 핵심기능으로 접근하는 방법을 제어하기 위해\r\n2. 핵심기능에 대해서 추가적인 기능을 주여해주기 위해\r\n```\r\n\r\n---\r\n## Spring AOP\r\n>Spring에서는 **Proxy**를 이용하여 AOP서비스를 제공한다  \r\n\r\n**1. JDK 동적 프록시**\r\n>>java 리플렉션을 이용하여 개체를 만드는 프록시\r\n\r\n**2. CGLIB 프록시**\r\n>> 바이트 코드를 조작하여 만드는 프록시\r\n\r\n_예전에는 AOP를 위해 interface를 구현해야 했지만, Spring3.2부터 CGLIB가 Spring core에 포함되면서 필요없어 졌다_\r\n\r\n![spring_aop_proxy](/resources/images/spring_aop_proxy.png)  \r\nAOP Object는 마치 자신인 핵심 Core Object처럼 꾸며서 흐름을 제어한다 \r\n\r\n---\r\n###Spring AOP를 사용하기 위한 주요 요건\r\n- **Aspect <span class=\"sub_header\">(@Aspect)</span>**\r\n>>공통 관심사를 모듈화 한 자바 클래스\r\n- **Advice <span class=\"sub_header\">(@Advice)</span>**\r\n>>무엇(What)이 실행될 것인지의 공통기능담은 구현체를 의미\r\n- **Pointcut <span class=\"sub_header\">(@Pointcut)</span>**\r\n>>어디에서(Where) Advice를 실행할 것인지를 정의\r\n\r\n<br/>\r\n\r\n###Advice  \r\n>>1. **Before** : 메서드 호출 이전  \r\n>>2. **After** : 메서드 호출 이후  \r\n>>3. **AfterReturning** : 메서드가 예외없이 실행된 이후  \r\n>>4. **AfterThrowing** : 메서드에 예외가 발생한 이후  \r\n>>5. **Around** : 메서드의 실행 전/후   \r\n\r\n<br/>\r\n\r\n###Pointcut\r\n\r\nPointcut|Joinpoints\r\n-----|-----\r\nexecution(public * *(..))|public 메소드 실행\r\nexecution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행\r\n|execution(* set*(..))|이름이 set으로 시작하는 모든 메소드명 실행|\r\n|execution(* com.xyz.service.AccountService.*(..))|AccountService 인터페이스의 모든 메소드 실행|\r\n|execution(* com.xyz.service.*.*(..))|service 패키지의 모든 메소드 실행|\r\n|execution(* com.xyz.service..*.*(..))|service 패키지와 하위 패키지의 모든 메소드 실행|\r\n|within(com.xyz.service.*)|service 패키지 내의 모든 결합점 (클래스 포함)|\r\n|within(com.xyz.service..*)|service 패키지 및 하위 패키지의 모든 결합점 (클래스 포함)|\r\n|this(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 프록시 개체의 모든 결합점|\r\n|target(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 대상 객체의 모든 결합점|\r\n|args(java.io.Serializable)|하나의 파라미터를 갖고 전달된 인자가 Serializable인 모든 결합점|\r\n|@target(org.springframework.transaction.annotation.Transactional)|대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@within(org.springframework.transaction.annotation.Transactional)|대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@annotation(org.springframework.transaction.annotation.Transactional)|실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점|\r\n|@args(com.xyz.security.Classified)|단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점|\r\n|bean(accountRepository)|“accountRepository” 빈|\r\n|!bean(accountRepository)|“accountRepository” 빈을 제외한 모든 빈|\r\n|bean(*)|모든 빈|\r\n|bean(account*)|이름이 'account'로 시작되는 모든 빈|\r\n|bean(*Repository)|이름이 “Repository”로 끝나는 모든 빈|\r\n|bean(accounting/*)|이름이 “accounting/“로 시작하는 모든 빈|\r\n|bean(*dataSource)  bean(*DataSource)|이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈|\r\n<span class=\"sub_header\">출처 : [얼청뚱땅 개발자 블로그](https://devjms.tistory.com/70)</span>\r\n\r\n<br/>\r\n\r\n###Simple Source\r\n\r\n<br/>\r\n\r\n***SpringBootApplication***\r\n```java\r\n\r\n@EnableAspectJAutoProxy //AOP 활성화\r\n@SpringBootApplication\r\npublic class SpringBootTestApplication implements CommandLineRunner {\r\n    ...\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SpringBootTestApplication.class, args);\r\n    }\r\n    \r\n    @Override\r\n    public void run(String... args) throws Exception {\r\n        simpleSource.test();\r\n    }\r\n    ...\r\n }\r\n\r\n```\r\n\r\n<br/>\r\n\r\n\r\n***AopClass***\r\n```java\r\n@Slf4j\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    @Before(\"execution(* com.service.SimpleSource.test(..))\")\r\n    public void aopBefore(){\r\n        log.info(\"aop before\");\r\n    }\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Recycle***\r\n\r\n```java\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    @Pointcut(\"execution(* *.*(..))\")\r\n    private void logging(){}\r\n    \r\n    @Around(\"logging()\")\r\n    public void aopBefore(){\r\n        log.info(\"aop around\");\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n\r\n<br/>\r\n\r\n---\r\n***Pointcut Exclude***\r\n\r\n```java\r\n\r\n@Service\r\npublic class SimpleSource {\r\n    ...\r\n    @NoLogging\r\n    public void logNo(){\r\n       ...\r\n    }\r\n    ...\r\n}\r\n-------------------------------------------------------\r\n@Aspect\r\n@Component\r\npublic class AopTest {\r\n    ...\r\n    \r\n    @Pointcut(\"execution(* *.*(..)) && !@target(com.annotation.NoLogging)\")\r\n    private void logging(){}\r\n    \r\n    ...\r\n}\r\n```\r\n*annotation을 구현해서 pointcut에 예외처리 지정하기*\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/spring_aop_20190904/"},"frontmatter":{"title":"Spring AOP","published":true}}},{"node":{"rawMarkdownBody":"\r\n## Elastic Timezone Issues\r\n>*elastic을 쓰면서 경험한 timezone 문제에 관한 글입니다*  \r\n\r\n###Logstash\r\n1. Logstash의 timezone은 색인할때의 정보가 아닌 filter 자체의 timezone으로 데이터로써 @timestamp의 ***Asia/Seoul***로 설정할시에 기존 시간에서 ***-9시간***을 한 시간을 가져 오게 된다  \r\n2. Logstash의 시간을 설정할 포맷을 정의 할때 timezone 키워드로 Asia/Seoul과 같이 지정해서 시간을 -9시간 할 수 있다\r\n```ruby\r\n   filter{ \r\n                ... \r\n                date{ \r\n                  match => [\"insert_ts\",\"YYYYMMddHHmmss\"] \r\n                  timezone => \"Asia/Seoul\" <- 이부분\r\n                } \r\n                ... \r\n          }\r\n```          \r\n\r\n<br/>\r\n\r\n3. Logstash의 timezone포맷에 +-로 시간을 변경 할 수 있다\r\n```ruby\r\nfilter{      \r\n      date{ \r\n          match => [\"insert_ts\",\"YYYYMMddHHmmss -0900\"] <- 이부분\r\n          timezone => \"Asia/Seoul\" \r\n          } \r\n}\r\n```\r\n\r\n<br/>\r\n\r\n4. ruby코드를 활용해서 시간 조정도 가능하다\r\n```ruby\r\nruby{ \r\n    code => \"event.set('@timestamp', LogStash::Timestamp.new(event.get('@timestamp')+(9*60*60)))\" \r\n}\r\n```\r\n\r\n이 코드의 핵심은 **LogStash::Timestamp**인데..  \r\n`ruby의 time객체`와 `LogStash의 time객체`가 다르다는 것이다<span class=\"sub_header\">(이것 때문에 겁나 해맸다)</span>  \r\n\r\n---\r\n\r\n###Kibana\r\n\r\n 1. 기본적으로 kibana의 Time 기분은 Browser를 따라 간다 <- 이거때문에 KST 기준일때 그래프가 정상적으로 보여서 혼동이 있었다\r\n 2. kibana의 time 기준은 Management > Advanced Settings > dateFormat:tz로 변경할 수 있다\r\n \r\n ---\r\n \r\n ###ElasticSearch\r\n \r\n  1. ElasticSearch의 기존 timezone은 UTC 기준이다 색인도 UTC 기준으로 하길 권고 하고 바꾸지 않기를 권고하고 있다  \r\n>-> 바꾸면 무한 timezone 관리로 계속해서 더 힘들어 질것\r\n  ","fields":{"slug":"/elastic_timezone/"},"frontmatter":{"title":"ElasticSearch Timezone 문제","published":true}}},{"node":{"rawMarkdownBody":"<figure class=\"float_left\" style=\"width: 400px\">\r\n\t<img src=\"/images/profile.jpg\" alt=\"profile\">\r\n</figure>\r\n\r\n<br/>\r\n\r\n#Deokhwa Kim \r\n*1992.01.10*\r\n\r\n**< Data Service Developer>**  \r\n*사람인HR LAB에 근무중*  \r\n**Spring**을 주로 사용하여 개발하며 요즘은 **Java**대신 **Kotlin**으로 개발하고 있습니다  \r\n\r\n---\r\n\r\n![dev_life](/resources/images/profile_dev_life.jpg)","fields":{"slug":"/profile/"},"frontmatter":{"title":"Profile","published":true}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}